{"ast":null,"code":"/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport ExpGolomb from './exp-golomb.js';\n\nclass SPSParser {\n  static _ebsp2rbsp(uint8array) {\n    let src = uint8array;\n    let src_length = src.byteLength;\n    let dst = new Uint8Array(src_length);\n    let dst_idx = 0;\n\n    for (let i = 0; i < src_length; i++) {\n      if (i >= 2) {\n        // Unescape: Skip 0x03 after 00 00\n        if (src[i] === 0x03 && src[i - 1] === 0x00 && src[i - 2] === 0x00) {\n          continue;\n        }\n      }\n\n      dst[dst_idx] = src[i];\n      dst_idx++;\n    }\n\n    return new Uint8Array(dst.buffer, 0, dst_idx);\n  }\n\n  static parseSPS(uint8array) {\n    let rbsp = SPSParser._ebsp2rbsp(uint8array);\n\n    let gb = new ExpGolomb(rbsp);\n    gb.readByte();\n    let profile_idc = gb.readByte(); // profile_idc\n\n    gb.readByte(); // constraint_set_flags[5] + reserved_zero[3]\n\n    let level_idc = gb.readByte(); // level_idc\n\n    gb.readUEG(); // seq_parameter_set_id\n\n    let profile_string = SPSParser.getProfileString(profile_idc);\n    let level_string = SPSParser.getLevelString(level_idc);\n    let chroma_format_idc = 1;\n    let chroma_format = 420;\n    let chroma_format_table = [0, 420, 422, 444];\n    let bit_depth = 8;\n\n    if (profile_idc === 100 || profile_idc === 110 || profile_idc === 122 || profile_idc === 244 || profile_idc === 44 || profile_idc === 83 || profile_idc === 86 || profile_idc === 118 || profile_idc === 128 || profile_idc === 138 || profile_idc === 144) {\n      chroma_format_idc = gb.readUEG();\n\n      if (chroma_format_idc === 3) {\n        gb.readBits(1); // separate_colour_plane_flag\n      }\n\n      if (chroma_format_idc <= 3) {\n        chroma_format = chroma_format_table[chroma_format_idc];\n      }\n\n      bit_depth = gb.readUEG() + 8; // bit_depth_luma_minus8\n\n      gb.readUEG(); // bit_depth_chroma_minus8\n\n      gb.readBits(1); // qpprime_y_zero_transform_bypass_flag\n\n      if (gb.readBool()) {\n        // seq_scaling_matrix_present_flag\n        let scaling_list_count = chroma_format_idc !== 3 ? 8 : 12;\n\n        for (let i = 0; i < scaling_list_count; i++) {\n          if (gb.readBool()) {\n            // seq_scaling_list_present_flag\n            if (i < 6) {\n              SPSParser._skipScalingList(gb, 16);\n            } else {\n              SPSParser._skipScalingList(gb, 64);\n            }\n          }\n        }\n      }\n    }\n\n    gb.readUEG(); // log2_max_frame_num_minus4\n\n    let pic_order_cnt_type = gb.readUEG();\n\n    if (pic_order_cnt_type === 0) {\n      gb.readUEG(); // log2_max_pic_order_cnt_lsb_minus_4\n    } else if (pic_order_cnt_type === 1) {\n      gb.readBits(1); // delta_pic_order_always_zero_flag\n\n      gb.readSEG(); // offset_for_non_ref_pic\n\n      gb.readSEG(); // offset_for_top_to_bottom_field\n\n      let num_ref_frames_in_pic_order_cnt_cycle = gb.readUEG();\n\n      for (let i = 0; i < num_ref_frames_in_pic_order_cnt_cycle; i++) {\n        gb.readSEG(); // offset_for_ref_frame\n      }\n    }\n\n    let ref_frames = gb.readUEG(); // max_num_ref_frames\n\n    gb.readBits(1); // gaps_in_frame_num_value_allowed_flag\n\n    let pic_width_in_mbs_minus1 = gb.readUEG();\n    let pic_height_in_map_units_minus1 = gb.readUEG();\n    let frame_mbs_only_flag = gb.readBits(1);\n\n    if (frame_mbs_only_flag === 0) {\n      gb.readBits(1); // mb_adaptive_frame_field_flag\n    }\n\n    gb.readBits(1); // direct_8x8_inference_flag\n\n    let frame_crop_left_offset = 0;\n    let frame_crop_right_offset = 0;\n    let frame_crop_top_offset = 0;\n    let frame_crop_bottom_offset = 0;\n    let frame_cropping_flag = gb.readBool();\n\n    if (frame_cropping_flag) {\n      frame_crop_left_offset = gb.readUEG();\n      frame_crop_right_offset = gb.readUEG();\n      frame_crop_top_offset = gb.readUEG();\n      frame_crop_bottom_offset = gb.readUEG();\n    }\n\n    let sar_width = 1,\n        sar_height = 1;\n    let fps = 0,\n        fps_fixed = true,\n        fps_num = 0,\n        fps_den = 0;\n    let vui_parameters_present_flag = gb.readBool();\n\n    if (vui_parameters_present_flag) {\n      if (gb.readBool()) {\n        // aspect_ratio_info_present_flag\n        let aspect_ratio_idc = gb.readByte();\n        let sar_w_table = [1, 12, 10, 16, 40, 24, 20, 32, 80, 18, 15, 64, 160, 4, 3, 2];\n        let sar_h_table = [1, 11, 11, 11, 33, 11, 11, 11, 33, 11, 11, 33, 99, 3, 2, 1];\n\n        if (aspect_ratio_idc > 0 && aspect_ratio_idc < 16) {\n          sar_width = sar_w_table[aspect_ratio_idc - 1];\n          sar_height = sar_h_table[aspect_ratio_idc - 1];\n        } else if (aspect_ratio_idc === 255) {\n          sar_width = gb.readByte() << 8 | gb.readByte();\n          sar_height = gb.readByte() << 8 | gb.readByte();\n        }\n      }\n\n      if (gb.readBool()) {\n        // overscan_info_present_flag\n        gb.readBool(); // overscan_appropriate_flag\n      }\n\n      if (gb.readBool()) {\n        // video_signal_type_present_flag\n        gb.readBits(4); // video_format & video_full_range_flag\n\n        if (gb.readBool()) {\n          // colour_description_present_flag\n          gb.readBits(24); // colour_primaries & transfer_characteristics & matrix_coefficients\n        }\n      }\n\n      if (gb.readBool()) {\n        // chroma_loc_info_present_flag\n        gb.readUEG(); // chroma_sample_loc_type_top_field\n\n        gb.readUEG(); // chroma_sample_loc_type_bottom_field\n      }\n\n      if (gb.readBool()) {\n        // timing_info_present_flag\n        let num_units_in_tick = gb.readBits(32);\n        let time_scale = gb.readBits(32);\n        fps_fixed = gb.readBool(); // fixed_frame_rate_flag\n\n        fps_num = time_scale;\n        fps_den = num_units_in_tick * 2;\n        fps = fps_num / fps_den;\n      }\n    }\n\n    let sarScale = 1;\n\n    if (sar_width !== 1 || sar_height !== 1) {\n      sarScale = sar_width / sar_height;\n    }\n\n    let crop_unit_x = 0,\n        crop_unit_y = 0;\n\n    if (chroma_format_idc === 0) {\n      crop_unit_x = 1;\n      crop_unit_y = 2 - frame_mbs_only_flag;\n    } else {\n      let sub_wc = chroma_format_idc === 3 ? 1 : 2;\n      let sub_hc = chroma_format_idc === 1 ? 2 : 1;\n      crop_unit_x = sub_wc;\n      crop_unit_y = sub_hc * (2 - frame_mbs_only_flag);\n    }\n\n    let codec_width = (pic_width_in_mbs_minus1 + 1) * 16;\n    let codec_height = (2 - frame_mbs_only_flag) * ((pic_height_in_map_units_minus1 + 1) * 16);\n    codec_width -= (frame_crop_left_offset + frame_crop_right_offset) * crop_unit_x;\n    codec_height -= (frame_crop_top_offset + frame_crop_bottom_offset) * crop_unit_y;\n    let present_width = Math.ceil(codec_width * sarScale);\n    gb.destroy();\n    gb = null;\n    return {\n      profile_string: profile_string,\n      // baseline, high, high10, ...\n      level_string: level_string,\n      // 3, 3.1, 4, 4.1, 5, 5.1, ...\n      bit_depth: bit_depth,\n      // 8bit, 10bit, ...\n      ref_frames: ref_frames,\n      chroma_format: chroma_format,\n      // 4:2:0, 4:2:2, ...\n      chroma_format_string: SPSParser.getChromaFormatString(chroma_format),\n      frame_rate: {\n        fixed: fps_fixed,\n        fps: fps,\n        fps_den: fps_den,\n        fps_num: fps_num\n      },\n      sar_ratio: {\n        width: sar_width,\n        height: sar_height\n      },\n      codec_size: {\n        width: codec_width,\n        height: codec_height\n      },\n      present_size: {\n        width: present_width,\n        height: codec_height\n      }\n    };\n  }\n\n  static _skipScalingList(gb, count) {\n    let last_scale = 8,\n        next_scale = 8;\n    let delta_scale = 0;\n\n    for (let i = 0; i < count; i++) {\n      if (next_scale !== 0) {\n        delta_scale = gb.readSEG();\n        next_scale = (last_scale + delta_scale + 256) % 256;\n      }\n\n      last_scale = next_scale === 0 ? last_scale : next_scale;\n    }\n  }\n\n  static getProfileString(profile_idc) {\n    switch (profile_idc) {\n      case 66:\n        return 'Baseline';\n\n      case 77:\n        return 'Main';\n\n      case 88:\n        return 'Extended';\n\n      case 100:\n        return 'High';\n\n      case 110:\n        return 'High10';\n\n      case 122:\n        return 'High422';\n\n      case 244:\n        return 'High444';\n\n      default:\n        return 'Unknown';\n    }\n  }\n\n  static getLevelString(level_idc) {\n    return (level_idc / 10).toFixed(1);\n  }\n\n  static getChromaFormatString(chroma) {\n    switch (chroma) {\n      case 420:\n        return '4:2:0';\n\n      case 422:\n        return '4:2:2';\n\n      case 444:\n        return '4:4:4';\n\n      default:\n        return 'Unknown';\n    }\n  }\n\n}\n\nexport default SPSParser;","map":null,"metadata":{},"sourceType":"module"}