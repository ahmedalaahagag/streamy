{"ast":null,"code":"/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport Log from '../utils/logger.js';\nimport { BaseLoader, LoaderStatus, LoaderErrors } from './loader.js';\nimport { RuntimeException } from '../utils/exception.js';\n/* Notice: ms-stream may cause IE/Edge browser crash if seek too frequently!!!\n * The browser may crash in wininet.dll. Disable for now.\n *\n * For IE11/Edge browser by microsoft which supports `xhr.responseType = 'ms-stream'`\n * Notice that ms-stream API sucks. The buffer is always expanding along with downloading.\n *\n * We need to abort the xhr if buffer size exceeded limit size (e.g. 16 MiB), then do reconnect.\n * in order to release previous ArrayBuffer to avoid memory leak\n *\n * Otherwise, the ArrayBuffer will increase to a terrible size that equals final file size.\n */\n\nclass MSStreamLoader extends BaseLoader {\n  static isSupported() {\n    try {\n      if (typeof self.MSStream === 'undefined' || typeof self.MSStreamReader === 'undefined') {\n        return false;\n      }\n\n      let xhr = new XMLHttpRequest();\n      xhr.open('GET', 'https://example.com', true);\n      xhr.responseType = 'ms-stream';\n      return xhr.responseType === 'ms-stream';\n    } catch (e) {\n      Log.w('MSStreamLoader', e.message);\n      return false;\n    }\n  }\n\n  constructor(seekHandler, config) {\n    super('xhr-msstream-loader');\n    this.TAG = 'MSStreamLoader';\n    this._seekHandler = seekHandler;\n    this._config = config;\n    this._needStash = true;\n    this._xhr = null;\n    this._reader = null; // MSStreamReader\n\n    this._totalRange = null;\n    this._currentRange = null;\n    this._currentRequestURL = null;\n    this._currentRedirectedURL = null;\n    this._contentLength = null;\n    this._receivedLength = 0;\n    this._bufferLimit = 16 * 1024 * 1024; // 16MB\n\n    this._lastTimeBufferSize = 0;\n    this._isReconnecting = false;\n  }\n\n  destroy() {\n    if (this.isWorking()) {\n      this.abort();\n    }\n\n    if (this._reader) {\n      this._reader.onprogress = null;\n      this._reader.onload = null;\n      this._reader.onerror = null;\n      this._reader = null;\n    }\n\n    if (this._xhr) {\n      this._xhr.onreadystatechange = null;\n      this._xhr = null;\n    }\n\n    super.destroy();\n  }\n\n  open(dataSource, range) {\n    this._internalOpen(dataSource, range, false);\n  }\n\n  _internalOpen(dataSource, range, isSubrange) {\n    this._dataSource = dataSource;\n\n    if (!isSubrange) {\n      this._totalRange = range;\n    } else {\n      this._currentRange = range;\n    }\n\n    let sourceURL = dataSource.url;\n\n    if (this._config.reuseRedirectedURL) {\n      if (this._currentRedirectedURL != undefined) {\n        sourceURL = this._currentRedirectedURL;\n      } else if (dataSource.redirectedURL != undefined) {\n        sourceURL = dataSource.redirectedURL;\n      }\n    }\n\n    let seekConfig = this._seekHandler.getConfig(sourceURL, range);\n\n    this._currentRequestURL = seekConfig.url;\n    let reader = this._reader = new self.MSStreamReader();\n    reader.onprogress = this._msrOnProgress.bind(this);\n    reader.onload = this._msrOnLoad.bind(this);\n    reader.onerror = this._msrOnError.bind(this);\n    let xhr = this._xhr = new XMLHttpRequest();\n    xhr.open('GET', seekConfig.url, true);\n    xhr.responseType = 'ms-stream';\n    xhr.onreadystatechange = this._xhrOnReadyStateChange.bind(this);\n    xhr.onerror = this._xhrOnError.bind(this);\n\n    if (dataSource.withCredentials) {\n      xhr.withCredentials = true;\n    }\n\n    if (typeof seekConfig.headers === 'object') {\n      let headers = seekConfig.headers;\n\n      for (let key in headers) {\n        if (headers.hasOwnProperty(key)) {\n          xhr.setRequestHeader(key, headers[key]);\n        }\n      }\n    } // add additional headers\n\n\n    if (typeof this._config.headers === 'object') {\n      let headers = this._config.headers;\n\n      for (let key in headers) {\n        if (headers.hasOwnProperty(key)) {\n          xhr.setRequestHeader(key, headers[key]);\n        }\n      }\n    }\n\n    if (this._isReconnecting) {\n      this._isReconnecting = false;\n    } else {\n      this._status = LoaderStatus.kConnecting;\n    }\n\n    xhr.send();\n  }\n\n  abort() {\n    this._internalAbort();\n\n    this._status = LoaderStatus.kComplete;\n  }\n\n  _internalAbort() {\n    if (this._reader) {\n      if (this._reader.readyState === 1) {\n        // LOADING\n        this._reader.abort();\n      }\n\n      this._reader.onprogress = null;\n      this._reader.onload = null;\n      this._reader.onerror = null;\n      this._reader = null;\n    }\n\n    if (this._xhr) {\n      this._xhr.abort();\n\n      this._xhr.onreadystatechange = null;\n      this._xhr = null;\n    }\n  }\n\n  _xhrOnReadyStateChange(e) {\n    let xhr = e.target;\n\n    if (xhr.readyState === 2) {\n      // HEADERS_RECEIVED\n      if (xhr.status >= 200 && xhr.status <= 299) {\n        this._status = LoaderStatus.kBuffering;\n\n        if (xhr.responseURL != undefined) {\n          let redirectedURL = this._seekHandler.removeURLParameters(xhr.responseURL);\n\n          if (xhr.responseURL !== this._currentRequestURL && redirectedURL !== this._currentRedirectedURL) {\n            this._currentRedirectedURL = redirectedURL;\n\n            if (this._onURLRedirect) {\n              this._onURLRedirect(redirectedURL);\n            }\n          }\n        }\n\n        let lengthHeader = xhr.getResponseHeader('Content-Length');\n\n        if (lengthHeader != null && this._contentLength == null) {\n          let length = parseInt(lengthHeader);\n\n          if (length > 0) {\n            this._contentLength = length;\n\n            if (this._onContentLengthKnown) {\n              this._onContentLengthKnown(this._contentLength);\n            }\n          }\n        }\n      } else {\n        this._status = LoaderStatus.kError;\n\n        if (this._onError) {\n          this._onError(LoaderErrors.HTTP_STATUS_CODE_INVALID, {\n            code: xhr.status,\n            msg: xhr.statusText\n          });\n        } else {\n          throw new RuntimeException('MSStreamLoader: Http code invalid, ' + xhr.status + ' ' + xhr.statusText);\n        }\n      }\n    } else if (xhr.readyState === 3) {\n      // LOADING\n      if (xhr.status >= 200 && xhr.status <= 299) {\n        this._status = LoaderStatus.kBuffering;\n        let msstream = xhr.response;\n\n        this._reader.readAsArrayBuffer(msstream);\n      }\n    }\n  }\n\n  _xhrOnError(e) {\n    this._status = LoaderStatus.kError;\n    let type = LoaderErrors.EXCEPTION;\n    let info = {\n      code: -1,\n      msg: e.constructor.name + ' ' + e.type\n    };\n\n    if (this._onError) {\n      this._onError(type, info);\n    } else {\n      throw new RuntimeException(info.msg);\n    }\n  }\n\n  _msrOnProgress(e) {\n    let reader = e.target;\n    let bigbuffer = reader.result;\n\n    if (bigbuffer == null) {\n      // result may be null, workaround for buggy M$\n      this._doReconnectIfNeeded();\n\n      return;\n    }\n\n    let slice = bigbuffer.slice(this._lastTimeBufferSize);\n    this._lastTimeBufferSize = bigbuffer.byteLength;\n    let byteStart = this._totalRange.from + this._receivedLength;\n    this._receivedLength += slice.byteLength;\n\n    if (this._onDataArrival) {\n      this._onDataArrival(slice, byteStart, this._receivedLength);\n    }\n\n    if (bigbuffer.byteLength >= this._bufferLimit) {\n      Log.v(this.TAG, \"MSStream buffer exceeded max size near \".concat(byteStart + slice.byteLength, \", reconnecting...\"));\n\n      this._doReconnectIfNeeded();\n    }\n  }\n\n  _doReconnectIfNeeded() {\n    if (this._contentLength == null || this._receivedLength < this._contentLength) {\n      this._isReconnecting = true;\n      this._lastTimeBufferSize = 0;\n\n      this._internalAbort();\n\n      let range = {\n        from: this._totalRange.from + this._receivedLength,\n        to: -1\n      };\n\n      this._internalOpen(this._dataSource, range, true);\n    }\n  }\n\n  _msrOnLoad(e) {\n    // actually it is onComplete event\n    this._status = LoaderStatus.kComplete;\n\n    if (this._onComplete) {\n      this._onComplete(this._totalRange.from, this._totalRange.from + this._receivedLength - 1);\n    }\n  }\n\n  _msrOnError(e) {\n    this._status = LoaderStatus.kError;\n    let type = 0;\n    let info = null;\n\n    if (this._contentLength && this._receivedLength < this._contentLength) {\n      type = LoaderErrors.EARLY_EOF;\n      info = {\n        code: -1,\n        msg: 'MSStream meet Early-Eof'\n      };\n    } else {\n      type = LoaderErrors.EARLY_EOF;\n      info = {\n        code: -1,\n        msg: e.constructor.name + ' ' + e.type\n      };\n    }\n\n    if (this._onError) {\n      this._onError(type, info);\n    } else {\n      throw new RuntimeException(info.msg);\n    }\n  }\n\n}\n\nexport default MSStreamLoader;","map":null,"metadata":{},"sourceType":"module"}