{"ast":null,"code":"/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport EventEmitter from 'events';\nimport Log from '../utils/logger.js';\nimport Browser from '../utils/browser.js';\nimport PlayerEvents from './player-events.js';\nimport Transmuxer from '../core/transmuxer.js';\nimport TransmuxingEvents from '../core/transmuxing-events.js';\nimport MSEController from '../core/mse-controller.js';\nimport MSEEvents from '../core/mse-events.js';\nimport { ErrorTypes, ErrorDetails } from './player-errors.js';\nimport { createDefaultConfig } from '../config.js';\nimport { InvalidArgumentException, IllegalStateException } from '../utils/exception.js';\n\nclass FlvPlayer {\n  constructor(mediaDataSource, config) {\n    this.TAG = 'FlvPlayer';\n    this._type = 'FlvPlayer';\n    this._emitter = new EventEmitter();\n    this._config = createDefaultConfig();\n\n    if (typeof config === 'object') {\n      Object.assign(this._config, config);\n    }\n\n    if (mediaDataSource.type.toLowerCase() !== 'flv') {\n      throw new InvalidArgumentException('FlvPlayer requires an flv MediaDataSource input!');\n    }\n\n    if (mediaDataSource.isLive === true) {\n      this._config.isLive = true;\n    }\n\n    this.e = {\n      onvLoadedMetadata: this._onvLoadedMetadata.bind(this),\n      onvSeeking: this._onvSeeking.bind(this),\n      onvCanPlay: this._onvCanPlay.bind(this),\n      onvStalled: this._onvStalled.bind(this),\n      onvProgress: this._onvProgress.bind(this)\n    };\n\n    if (self.performance && self.performance.now) {\n      this._now = self.performance.now.bind(self.performance);\n    } else {\n      this._now = Date.now;\n    }\n\n    this._pendingSeekTime = null; // in seconds\n\n    this._requestSetTime = false;\n    this._seekpointRecord = null;\n    this._progressChecker = null;\n    this._mediaDataSource = mediaDataSource;\n    this._mediaElement = null;\n    this._msectl = null;\n    this._transmuxer = null;\n    this._mseSourceOpened = false;\n    this._hasPendingLoad = false;\n    this._receivedCanPlay = false;\n    this._mediaInfo = null;\n    this._statisticsInfo = null;\n    let chromeNeedIDRFix = Browser.chrome && (Browser.version.major < 50 || Browser.version.major === 50 && Browser.version.build < 2661);\n    this._alwaysSeekKeyframe = chromeNeedIDRFix || Browser.msedge || Browser.msie ? true : false;\n\n    if (this._alwaysSeekKeyframe) {\n      this._config.accurateSeek = false;\n    }\n  }\n\n  destroy() {\n    if (this._progressChecker != null) {\n      window.clearInterval(this._progressChecker);\n      this._progressChecker = null;\n    }\n\n    if (this._transmuxer) {\n      this.unload();\n    }\n\n    if (this._mediaElement) {\n      this.detachMediaElement();\n    }\n\n    this.e = null;\n    this._mediaDataSource = null;\n\n    this._emitter.removeAllListeners();\n\n    this._emitter = null;\n  }\n\n  on(event, listener) {\n    if (event === PlayerEvents.MEDIA_INFO) {\n      if (this._mediaInfo != null) {\n        Promise.resolve().then(() => {\n          this._emitter.emit(PlayerEvents.MEDIA_INFO, this.mediaInfo);\n        });\n      }\n    } else if (event === PlayerEvents.STATISTICS_INFO) {\n      if (this._statisticsInfo != null) {\n        Promise.resolve().then(() => {\n          this._emitter.emit(PlayerEvents.STATISTICS_INFO, this.statisticsInfo);\n        });\n      }\n    }\n\n    this._emitter.addListener(event, listener);\n  }\n\n  off(event, listener) {\n    this._emitter.removeListener(event, listener);\n  }\n\n  attachMediaElement(mediaElement) {\n    this._mediaElement = mediaElement;\n    mediaElement.addEventListener('loadedmetadata', this.e.onvLoadedMetadata);\n    mediaElement.addEventListener('seeking', this.e.onvSeeking);\n    mediaElement.addEventListener('canplay', this.e.onvCanPlay);\n    mediaElement.addEventListener('stalled', this.e.onvStalled);\n    mediaElement.addEventListener('progress', this.e.onvProgress);\n    this._msectl = new MSEController(this._config);\n\n    this._msectl.on(MSEEvents.UPDATE_END, this._onmseUpdateEnd.bind(this));\n\n    this._msectl.on(MSEEvents.BUFFER_FULL, this._onmseBufferFull.bind(this));\n\n    this._msectl.on(MSEEvents.SOURCE_OPEN, () => {\n      this._mseSourceOpened = true;\n\n      if (this._hasPendingLoad) {\n        this._hasPendingLoad = false;\n        this.load();\n      }\n    });\n\n    this._msectl.on(MSEEvents.ERROR, info => {\n      this._emitter.emit(PlayerEvents.ERROR, ErrorTypes.MEDIA_ERROR, ErrorDetails.MEDIA_MSE_ERROR, info);\n    });\n\n    this._msectl.attachMediaElement(mediaElement);\n\n    if (this._pendingSeekTime != null) {\n      try {\n        mediaElement.currentTime = this._pendingSeekTime;\n        this._pendingSeekTime = null;\n      } catch (e) {// IE11 may throw InvalidStateError if readyState === 0\n        // We can defer set currentTime operation after loadedmetadata\n      }\n    }\n  }\n\n  detachMediaElement() {\n    if (this._mediaElement) {\n      this._msectl.detachMediaElement();\n\n      this._mediaElement.removeEventListener('loadedmetadata', this.e.onvLoadedMetadata);\n\n      this._mediaElement.removeEventListener('seeking', this.e.onvSeeking);\n\n      this._mediaElement.removeEventListener('canplay', this.e.onvCanPlay);\n\n      this._mediaElement.removeEventListener('stalled', this.e.onvStalled);\n\n      this._mediaElement.removeEventListener('progress', this.e.onvProgress);\n\n      this._mediaElement = null;\n    }\n\n    if (this._msectl) {\n      this._msectl.destroy();\n\n      this._msectl = null;\n    }\n  }\n\n  load() {\n    if (!this._mediaElement) {\n      throw new IllegalStateException('HTMLMediaElement must be attached before load()!');\n    }\n\n    if (this._transmuxer) {\n      throw new IllegalStateException('FlvPlayer.load() has been called, please call unload() first!');\n    }\n\n    if (this._hasPendingLoad) {\n      return;\n    }\n\n    if (this._config.deferLoadAfterSourceOpen && this._mseSourceOpened === false) {\n      this._hasPendingLoad = true;\n      return;\n    }\n\n    if (this._mediaElement.readyState > 0) {\n      this._requestSetTime = true; // IE11 may throw InvalidStateError if readyState === 0\n\n      this._mediaElement.currentTime = 0;\n    }\n\n    this._transmuxer = new Transmuxer(this._mediaDataSource, this._config);\n\n    this._transmuxer.on(TransmuxingEvents.INIT_SEGMENT, (type, is) => {\n      this._msectl.appendInitSegment(is);\n    });\n\n    this._transmuxer.on(TransmuxingEvents.MEDIA_SEGMENT, (type, ms) => {\n      this._msectl.appendMediaSegment(ms); // lazyLoad check\n\n\n      if (this._config.lazyLoad && !this._config.isLive) {\n        let currentTime = this._mediaElement.currentTime;\n\n        if (ms.info.endDts >= (currentTime + this._config.lazyLoadMaxDuration) * 1000) {\n          if (this._progressChecker == null) {\n            Log.v(this.TAG, 'Maximum buffering duration exceeded, suspend transmuxing task');\n\n            this._suspendTransmuxer();\n          }\n        }\n      }\n    });\n\n    this._transmuxer.on(TransmuxingEvents.LOADING_COMPLETE, () => {\n      this._msectl.endOfStream();\n\n      this._emitter.emit(PlayerEvents.LOADING_COMPLETE);\n    });\n\n    this._transmuxer.on(TransmuxingEvents.RECOVERED_EARLY_EOF, () => {\n      this._emitter.emit(PlayerEvents.RECOVERED_EARLY_EOF);\n    });\n\n    this._transmuxer.on(TransmuxingEvents.IO_ERROR, (detail, info) => {\n      this._emitter.emit(PlayerEvents.ERROR, ErrorTypes.NETWORK_ERROR, detail, info);\n    });\n\n    this._transmuxer.on(TransmuxingEvents.DEMUX_ERROR, (detail, info) => {\n      this._emitter.emit(PlayerEvents.ERROR, ErrorTypes.MEDIA_ERROR, detail, {\n        code: -1,\n        msg: info\n      });\n    });\n\n    this._transmuxer.on(TransmuxingEvents.MEDIA_INFO, mediaInfo => {\n      this._mediaInfo = mediaInfo;\n\n      this._emitter.emit(PlayerEvents.MEDIA_INFO, Object.assign({}, mediaInfo));\n    });\n\n    this._transmuxer.on(TransmuxingEvents.METADATA_ARRIVED, metadata => {\n      this._emitter.emit(PlayerEvents.METADATA_ARRIVED, metadata);\n    });\n\n    this._transmuxer.on(TransmuxingEvents.SCRIPTDATA_ARRIVED, data => {\n      this._emitter.emit(PlayerEvents.SCRIPTDATA_ARRIVED, data);\n    });\n\n    this._transmuxer.on(TransmuxingEvents.STATISTICS_INFO, statInfo => {\n      this._statisticsInfo = this._fillStatisticsInfo(statInfo);\n\n      this._emitter.emit(PlayerEvents.STATISTICS_INFO, Object.assign({}, this._statisticsInfo));\n    });\n\n    this._transmuxer.on(TransmuxingEvents.RECOMMEND_SEEKPOINT, milliseconds => {\n      if (this._mediaElement && !this._config.accurateSeek) {\n        this._requestSetTime = true;\n        this._mediaElement.currentTime = milliseconds / 1000;\n      }\n    });\n\n    this._transmuxer.open();\n  }\n\n  unload() {\n    if (this._mediaElement) {\n      this._mediaElement.pause();\n    }\n\n    if (this._msectl) {\n      this._msectl.seek(0);\n    }\n\n    if (this._transmuxer) {\n      this._transmuxer.close();\n\n      this._transmuxer.destroy();\n\n      this._transmuxer = null;\n    }\n  }\n\n  play() {\n    return this._mediaElement.play();\n  }\n\n  pause() {\n    this._mediaElement.pause();\n  }\n\n  get type() {\n    return this._type;\n  }\n\n  get buffered() {\n    return this._mediaElement.buffered;\n  }\n\n  get duration() {\n    return this._mediaElement.duration;\n  }\n\n  get volume() {\n    return this._mediaElement.volume;\n  }\n\n  set volume(value) {\n    this._mediaElement.volume = value;\n  }\n\n  get muted() {\n    return this._mediaElement.muted;\n  }\n\n  set muted(muted) {\n    this._mediaElement.muted = muted;\n  }\n\n  get currentTime() {\n    if (this._mediaElement) {\n      return this._mediaElement.currentTime;\n    }\n\n    return 0;\n  }\n\n  set currentTime(seconds) {\n    if (this._mediaElement) {\n      this._internalSeek(seconds);\n    } else {\n      this._pendingSeekTime = seconds;\n    }\n  }\n\n  get mediaInfo() {\n    return Object.assign({}, this._mediaInfo);\n  }\n\n  get statisticsInfo() {\n    if (this._statisticsInfo == null) {\n      this._statisticsInfo = {};\n    }\n\n    this._statisticsInfo = this._fillStatisticsInfo(this._statisticsInfo);\n    return Object.assign({}, this._statisticsInfo);\n  }\n\n  _fillStatisticsInfo(statInfo) {\n    statInfo.playerType = this._type;\n\n    if (!(this._mediaElement instanceof HTMLVideoElement)) {\n      return statInfo;\n    }\n\n    let hasQualityInfo = true;\n    let decoded = 0;\n    let dropped = 0;\n\n    if (this._mediaElement.getVideoPlaybackQuality) {\n      let quality = this._mediaElement.getVideoPlaybackQuality();\n\n      decoded = quality.totalVideoFrames;\n      dropped = quality.droppedVideoFrames;\n    } else if (this._mediaElement.webkitDecodedFrameCount != undefined) {\n      decoded = this._mediaElement.webkitDecodedFrameCount;\n      dropped = this._mediaElement.webkitDroppedFrameCount;\n    } else {\n      hasQualityInfo = false;\n    }\n\n    if (hasQualityInfo) {\n      statInfo.decodedFrames = decoded;\n      statInfo.droppedFrames = dropped;\n    }\n\n    return statInfo;\n  }\n\n  _onmseUpdateEnd() {\n    if (!this._config.lazyLoad || this._config.isLive) {\n      return;\n    }\n\n    let buffered = this._mediaElement.buffered;\n    let currentTime = this._mediaElement.currentTime;\n    let currentRangeStart = 0;\n    let currentRangeEnd = 0;\n\n    for (let i = 0; i < buffered.length; i++) {\n      let start = buffered.start(i);\n      let end = buffered.end(i);\n\n      if (start <= currentTime && currentTime < end) {\n        currentRangeStart = start;\n        currentRangeEnd = end;\n        break;\n      }\n    }\n\n    if (currentRangeEnd >= currentTime + this._config.lazyLoadMaxDuration && this._progressChecker == null) {\n      Log.v(this.TAG, 'Maximum buffering duration exceeded, suspend transmuxing task');\n\n      this._suspendTransmuxer();\n    }\n  }\n\n  _onmseBufferFull() {\n    Log.v(this.TAG, 'MSE SourceBuffer is full, suspend transmuxing task');\n\n    if (this._progressChecker == null) {\n      this._suspendTransmuxer();\n    }\n  }\n\n  _suspendTransmuxer() {\n    if (this._transmuxer) {\n      this._transmuxer.pause();\n\n      if (this._progressChecker == null) {\n        this._progressChecker = window.setInterval(this._checkProgressAndResume.bind(this), 1000);\n      }\n    }\n  }\n\n  _checkProgressAndResume() {\n    let currentTime = this._mediaElement.currentTime;\n    let buffered = this._mediaElement.buffered;\n    let needResume = false;\n\n    for (let i = 0; i < buffered.length; i++) {\n      let from = buffered.start(i);\n      let to = buffered.end(i);\n\n      if (currentTime >= from && currentTime < to) {\n        if (currentTime >= to - this._config.lazyLoadRecoverDuration) {\n          needResume = true;\n        }\n\n        break;\n      }\n    }\n\n    if (needResume) {\n      window.clearInterval(this._progressChecker);\n      this._progressChecker = null;\n\n      if (needResume) {\n        Log.v(this.TAG, 'Continue loading from paused position');\n\n        this._transmuxer.resume();\n      }\n    }\n  }\n\n  _isTimepointBuffered(seconds) {\n    let buffered = this._mediaElement.buffered;\n\n    for (let i = 0; i < buffered.length; i++) {\n      let from = buffered.start(i);\n      let to = buffered.end(i);\n\n      if (seconds >= from && seconds < to) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  _internalSeek(seconds) {\n    let directSeek = this._isTimepointBuffered(seconds);\n\n    let directSeekBegin = false;\n    let directSeekBeginTime = 0;\n\n    if (seconds < 1.0 && this._mediaElement.buffered.length > 0) {\n      let videoBeginTime = this._mediaElement.buffered.start(0);\n\n      if (videoBeginTime < 1.0 && seconds < videoBeginTime || Browser.safari) {\n        directSeekBegin = true; // also workaround for Safari: Seek to 0 may cause video stuck, use 0.1 to avoid\n\n        directSeekBeginTime = Browser.safari ? 0.1 : videoBeginTime;\n      }\n    }\n\n    if (directSeekBegin) {\n      // seek to video begin, set currentTime directly if beginPTS buffered\n      this._requestSetTime = true;\n      this._mediaElement.currentTime = directSeekBeginTime;\n    } else if (directSeek) {\n      // buffered position\n      if (!this._alwaysSeekKeyframe) {\n        this._requestSetTime = true;\n        this._mediaElement.currentTime = seconds;\n      } else {\n        let idr = this._msectl.getNearestKeyframe(Math.floor(seconds * 1000));\n\n        this._requestSetTime = true;\n\n        if (idr != null) {\n          this._mediaElement.currentTime = idr.dts / 1000;\n        } else {\n          this._mediaElement.currentTime = seconds;\n        }\n      }\n\n      if (this._progressChecker != null) {\n        this._checkProgressAndResume();\n      }\n    } else {\n      if (this._progressChecker != null) {\n        window.clearInterval(this._progressChecker);\n        this._progressChecker = null;\n      }\n\n      this._msectl.seek(seconds);\n\n      this._transmuxer.seek(Math.floor(seconds * 1000)); // in milliseconds\n      // no need to set mediaElement.currentTime if non-accurateSeek,\n      // just wait for the recommend_seekpoint callback\n\n\n      if (this._config.accurateSeek) {\n        this._requestSetTime = true;\n        this._mediaElement.currentTime = seconds;\n      }\n    }\n  }\n\n  _checkAndApplyUnbufferedSeekpoint() {\n    if (this._seekpointRecord) {\n      if (this._seekpointRecord.recordTime <= this._now() - 100) {\n        let target = this._mediaElement.currentTime;\n        this._seekpointRecord = null;\n\n        if (!this._isTimepointBuffered(target)) {\n          if (this._progressChecker != null) {\n            window.clearTimeout(this._progressChecker);\n            this._progressChecker = null;\n          } // .currentTime is consists with .buffered timestamp\n          // Chrome/Edge use DTS, while FireFox/Safari use PTS\n\n\n          this._msectl.seek(target);\n\n          this._transmuxer.seek(Math.floor(target * 1000)); // set currentTime if accurateSeek, or wait for recommend_seekpoint callback\n\n\n          if (this._config.accurateSeek) {\n            this._requestSetTime = true;\n            this._mediaElement.currentTime = target;\n          }\n        }\n      } else {\n        window.setTimeout(this._checkAndApplyUnbufferedSeekpoint.bind(this), 50);\n      }\n    }\n  }\n\n  _checkAndResumeStuckPlayback(stalled) {\n    let media = this._mediaElement;\n\n    if (stalled || !this._receivedCanPlay || media.readyState < 2) {\n      // HAVE_CURRENT_DATA\n      let buffered = media.buffered;\n\n      if (buffered.length > 0 && media.currentTime < buffered.start(0)) {\n        Log.w(this.TAG, \"Playback seems stuck at \".concat(media.currentTime, \", seek to \").concat(buffered.start(0)));\n        this._requestSetTime = true;\n        this._mediaElement.currentTime = buffered.start(0);\n\n        this._mediaElement.removeEventListener('progress', this.e.onvProgress);\n      }\n    } else {\n      // Playback didn't stuck, remove progress event listener\n      this._mediaElement.removeEventListener('progress', this.e.onvProgress);\n    }\n  }\n\n  _onvLoadedMetadata(e) {\n    if (this._pendingSeekTime != null) {\n      this._mediaElement.currentTime = this._pendingSeekTime;\n      this._pendingSeekTime = null;\n    }\n  }\n\n  _onvSeeking(e) {\n    // handle seeking request from browser's progress bar\n    let target = this._mediaElement.currentTime;\n    let buffered = this._mediaElement.buffered;\n\n    if (this._requestSetTime) {\n      this._requestSetTime = false;\n      return;\n    }\n\n    if (target < 1.0 && buffered.length > 0) {\n      // seek to video begin, set currentTime directly if beginPTS buffered\n      let videoBeginTime = buffered.start(0);\n\n      if (videoBeginTime < 1.0 && target < videoBeginTime || Browser.safari) {\n        this._requestSetTime = true; // also workaround for Safari: Seek to 0 may cause video stuck, use 0.1 to avoid\n\n        this._mediaElement.currentTime = Browser.safari ? 0.1 : videoBeginTime;\n        return;\n      }\n    }\n\n    if (this._isTimepointBuffered(target)) {\n      if (this._alwaysSeekKeyframe) {\n        let idr = this._msectl.getNearestKeyframe(Math.floor(target * 1000));\n\n        if (idr != null) {\n          this._requestSetTime = true;\n          this._mediaElement.currentTime = idr.dts / 1000;\n        }\n      }\n\n      if (this._progressChecker != null) {\n        this._checkProgressAndResume();\n      }\n\n      return;\n    }\n\n    this._seekpointRecord = {\n      seekPoint: target,\n      recordTime: this._now()\n    };\n    window.setTimeout(this._checkAndApplyUnbufferedSeekpoint.bind(this), 50);\n  }\n\n  _onvCanPlay(e) {\n    this._receivedCanPlay = true;\n\n    this._mediaElement.removeEventListener('canplay', this.e.onvCanPlay);\n  }\n\n  _onvStalled(e) {\n    this._checkAndResumeStuckPlayback(true);\n  }\n\n  _onvProgress(e) {\n    this._checkAndResumeStuckPlayback();\n  }\n\n}\n\nexport default FlvPlayer;","map":null,"metadata":{},"sourceType":"module"}