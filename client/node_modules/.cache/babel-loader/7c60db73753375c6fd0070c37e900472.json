{"ast":null,"code":"/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport Log from '../utils/logger.js';\nimport Browser from '../utils/browser.js';\nimport { BaseLoader, LoaderStatus, LoaderErrors } from './loader.js';\nimport { RuntimeException } from '../utils/exception.js';\n/* fetch + stream IO loader. Currently working on chrome 43+.\n * fetch provides a better alternative http API to XMLHttpRequest\n *\n * fetch spec   https://fetch.spec.whatwg.org/\n * stream spec  https://streams.spec.whatwg.org/\n */\n\nclass FetchStreamLoader extends BaseLoader {\n  static isSupported() {\n    try {\n      // fetch + stream is broken on Microsoft Edge. Disable before build 15048.\n      // see https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8196907/\n      // Fixed in Jan 10, 2017. Build 15048+ removed from blacklist.\n      let isWorkWellEdge = Browser.msedge && Browser.version.minor >= 15048;\n      let browserNotBlacklisted = Browser.msedge ? isWorkWellEdge : true;\n      return self.fetch && self.ReadableStream && browserNotBlacklisted;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  constructor(seekHandler, config) {\n    super('fetch-stream-loader');\n    this.TAG = 'FetchStreamLoader';\n    this._seekHandler = seekHandler;\n    this._config = config;\n    this._needStash = true;\n    this._requestAbort = false;\n    this._contentLength = null;\n    this._receivedLength = 0;\n  }\n\n  destroy() {\n    if (this.isWorking()) {\n      this.abort();\n    }\n\n    super.destroy();\n  }\n\n  open(dataSource, range) {\n    this._dataSource = dataSource;\n    this._range = range;\n    let sourceURL = dataSource.url;\n\n    if (this._config.reuseRedirectedURL && dataSource.redirectedURL != undefined) {\n      sourceURL = dataSource.redirectedURL;\n    }\n\n    let seekConfig = this._seekHandler.getConfig(sourceURL, range);\n\n    let headers = new self.Headers();\n\n    if (typeof seekConfig.headers === 'object') {\n      let configHeaders = seekConfig.headers;\n\n      for (let key in configHeaders) {\n        if (configHeaders.hasOwnProperty(key)) {\n          headers.append(key, configHeaders[key]);\n        }\n      }\n    }\n\n    let params = {\n      method: 'GET',\n      headers: headers,\n      mode: 'cors',\n      cache: 'default',\n      // The default policy of Fetch API in the whatwg standard\n      // Safari incorrectly indicates 'no-referrer' as default policy, fuck it\n      referrerPolicy: 'no-referrer-when-downgrade'\n    }; // add additional headers\n\n    if (typeof this._config.headers === 'object') {\n      for (let key in this._config.headers) {\n        headers.append(key, this._config.headers[key]);\n      }\n    } // cors is enabled by default\n\n\n    if (dataSource.cors === false) {\n      // no-cors means 'disregard cors policy', which can only be used in ServiceWorker\n      params.mode = 'same-origin';\n    } // withCredentials is disabled by default\n\n\n    if (dataSource.withCredentials) {\n      params.credentials = 'include';\n    } // referrerPolicy from config\n\n\n    if (dataSource.referrerPolicy) {\n      params.referrerPolicy = dataSource.referrerPolicy;\n    }\n\n    this._status = LoaderStatus.kConnecting;\n    self.fetch(seekConfig.url, params).then(res => {\n      if (this._requestAbort) {\n        this._requestAbort = false;\n        this._status = LoaderStatus.kIdle;\n        return;\n      }\n\n      if (res.ok && res.status >= 200 && res.status <= 299) {\n        if (res.url !== seekConfig.url) {\n          if (this._onURLRedirect) {\n            let redirectedURL = this._seekHandler.removeURLParameters(res.url);\n\n            this._onURLRedirect(redirectedURL);\n          }\n        }\n\n        let lengthHeader = res.headers.get('Content-Length');\n\n        if (lengthHeader != null) {\n          this._contentLength = parseInt(lengthHeader);\n\n          if (this._contentLength !== 0) {\n            if (this._onContentLengthKnown) {\n              this._onContentLengthKnown(this._contentLength);\n            }\n          }\n        }\n\n        return this._pump.call(this, res.body.getReader());\n      } else {\n        this._status = LoaderStatus.kError;\n\n        if (this._onError) {\n          this._onError(LoaderErrors.HTTP_STATUS_CODE_INVALID, {\n            code: res.status,\n            msg: res.statusText\n          });\n        } else {\n          throw new RuntimeException('FetchStreamLoader: Http code invalid, ' + res.status + ' ' + res.statusText);\n        }\n      }\n    }).catch(e => {\n      this._status = LoaderStatus.kError;\n\n      if (this._onError) {\n        this._onError(LoaderErrors.EXCEPTION, {\n          code: -1,\n          msg: e.message\n        });\n      } else {\n        throw e;\n      }\n    });\n  }\n\n  abort() {\n    this._requestAbort = true;\n  }\n\n  _pump(reader) {\n    // ReadableStreamReader\n    return reader.read().then(result => {\n      if (result.done) {\n        // First check received length\n        if (this._contentLength !== null && this._receivedLength < this._contentLength) {\n          // Report Early-EOF\n          this._status = LoaderStatus.kError;\n          let type = LoaderErrors.EARLY_EOF;\n          let info = {\n            code: -1,\n            msg: 'Fetch stream meet Early-EOF'\n          };\n\n          if (this._onError) {\n            this._onError(type, info);\n          } else {\n            throw new RuntimeException(info.msg);\n          }\n        } else {\n          // OK. Download complete\n          this._status = LoaderStatus.kComplete;\n\n          if (this._onComplete) {\n            this._onComplete(this._range.from, this._range.from + this._receivedLength - 1);\n          }\n        }\n      } else {\n        if (this._requestAbort === true) {\n          this._requestAbort = false;\n          this._status = LoaderStatus.kComplete;\n          return reader.cancel();\n        }\n\n        this._status = LoaderStatus.kBuffering;\n        let chunk = result.value.buffer;\n        let byteStart = this._range.from + this._receivedLength;\n        this._receivedLength += chunk.byteLength;\n\n        if (this._onDataArrival) {\n          this._onDataArrival(chunk, byteStart, this._receivedLength);\n        }\n\n        this._pump(reader);\n      }\n    }).catch(e => {\n      if (e.code === 11 && Browser.msedge) {\n        // InvalidStateError on Microsoft Edge\n        // Workaround: Edge may throw InvalidStateError after ReadableStreamReader.cancel() call\n        // Ignore the unknown exception.\n        // Related issue: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11265202/\n        return;\n      }\n\n      this._status = LoaderStatus.kError;\n      let type = 0;\n      let info = null;\n\n      if ((e.code === 19 || e.message === 'network error') && ( // NETWORK_ERR\n      this._contentLength === null || this._contentLength !== null && this._receivedLength < this._contentLength)) {\n        type = LoaderErrors.EARLY_EOF;\n        info = {\n          code: e.code,\n          msg: 'Fetch stream meet Early-EOF'\n        };\n      } else {\n        type = LoaderErrors.EXCEPTION;\n        info = {\n          code: e.code,\n          msg: e.message\n        };\n      }\n\n      if (this._onError) {\n        this._onError(type, info);\n      } else {\n        throw new RuntimeException(info.msg);\n      }\n    });\n  }\n\n}\n\nexport default FetchStreamLoader;","map":null,"metadata":{},"sourceType":"module"}