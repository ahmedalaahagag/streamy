{"ast":null,"code":"/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport Log from '../utils/logger.js';\nimport AMF from './amf-parser.js';\nimport SPSParser from './sps-parser.js';\nimport DemuxErrors from './demux-errors.js';\nimport MediaInfo from '../core/media-info.js';\nimport { IllegalStateException } from '../utils/exception.js';\n\nfunction Swap16(src) {\n  return src >>> 8 & 0xFF | (src & 0xFF) << 8;\n}\n\nfunction Swap32(src) {\n  return (src & 0xFF000000) >>> 24 | (src & 0x00FF0000) >>> 8 | (src & 0x0000FF00) << 8 | (src & 0x000000FF) << 24;\n}\n\nfunction ReadBig32(array, index) {\n  return array[index] << 24 | array[index + 1] << 16 | array[index + 2] << 8 | array[index + 3];\n}\n\nclass FLVDemuxer {\n  constructor(probeData, config) {\n    this.TAG = 'FLVDemuxer';\n    this._config = config;\n    this._onError = null;\n    this._onMediaInfo = null;\n    this._onMetaDataArrived = null;\n    this._onScriptDataArrived = null;\n    this._onTrackMetadata = null;\n    this._onDataAvailable = null;\n    this._dataOffset = probeData.dataOffset;\n    this._firstParse = true;\n    this._dispatch = false;\n    this._hasAudio = probeData.hasAudioTrack;\n    this._hasVideo = probeData.hasVideoTrack;\n    this._hasAudioFlagOverrided = false;\n    this._hasVideoFlagOverrided = false;\n    this._audioInitialMetadataDispatched = false;\n    this._videoInitialMetadataDispatched = false;\n    this._mediaInfo = new MediaInfo();\n    this._mediaInfo.hasAudio = this._hasAudio;\n    this._mediaInfo.hasVideo = this._hasVideo;\n    this._metadata = null;\n    this._audioMetadata = null;\n    this._videoMetadata = null;\n    this._naluLengthSize = 4;\n    this._timestampBase = 0; // int32, in milliseconds\n\n    this._timescale = 1000;\n    this._duration = 0; // int32, in milliseconds\n\n    this._durationOverrided = false;\n    this._referenceFrameRate = {\n      fixed: true,\n      fps: 23.976,\n      fps_num: 23976,\n      fps_den: 1000\n    };\n    this._flvSoundRateTable = [5500, 11025, 22050, 44100, 48000];\n    this._mpegSamplingRates = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];\n    this._mpegAudioV10SampleRateTable = [44100, 48000, 32000, 0];\n    this._mpegAudioV20SampleRateTable = [22050, 24000, 16000, 0];\n    this._mpegAudioV25SampleRateTable = [11025, 12000, 8000, 0];\n    this._mpegAudioL1BitRateTable = [0, 32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, -1];\n    this._mpegAudioL2BitRateTable = [0, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, -1];\n    this._mpegAudioL3BitRateTable = [0, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, -1];\n    this._videoTrack = {\n      type: 'video',\n      id: 1,\n      sequenceNumber: 0,\n      samples: [],\n      length: 0\n    };\n    this._audioTrack = {\n      type: 'audio',\n      id: 2,\n      sequenceNumber: 0,\n      samples: [],\n      length: 0\n    };\n\n    this._littleEndian = function () {\n      let buf = new ArrayBuffer(2);\n      new DataView(buf).setInt16(0, 256, true); // little-endian write\n\n      return new Int16Array(buf)[0] === 256; // platform-spec read, if equal then LE\n    }();\n  }\n\n  destroy() {\n    this._mediaInfo = null;\n    this._metadata = null;\n    this._audioMetadata = null;\n    this._videoMetadata = null;\n    this._videoTrack = null;\n    this._audioTrack = null;\n    this._onError = null;\n    this._onMediaInfo = null;\n    this._onMetaDataArrived = null;\n    this._onScriptDataArrived = null;\n    this._onTrackMetadata = null;\n    this._onDataAvailable = null;\n  }\n\n  static probe(buffer) {\n    let data = new Uint8Array(buffer);\n    let mismatch = {\n      match: false\n    };\n\n    if (data[0] !== 0x46 || data[1] !== 0x4C || data[2] !== 0x56 || data[3] !== 0x01) {\n      return mismatch;\n    }\n\n    let hasAudio = (data[4] & 4) >>> 2 !== 0;\n    let hasVideo = (data[4] & 1) !== 0;\n    let offset = ReadBig32(data, 5);\n\n    if (offset < 9) {\n      return mismatch;\n    }\n\n    return {\n      match: true,\n      consumed: offset,\n      dataOffset: offset,\n      hasAudioTrack: hasAudio,\n      hasVideoTrack: hasVideo\n    };\n  }\n\n  bindDataSource(loader) {\n    loader.onDataArrival = this.parseChunks.bind(this);\n    return this;\n  } // prototype: function(type: string, metadata: any): void\n\n\n  get onTrackMetadata() {\n    return this._onTrackMetadata;\n  }\n\n  set onTrackMetadata(callback) {\n    this._onTrackMetadata = callback;\n  } // prototype: function(mediaInfo: MediaInfo): void\n\n\n  get onMediaInfo() {\n    return this._onMediaInfo;\n  }\n\n  set onMediaInfo(callback) {\n    this._onMediaInfo = callback;\n  }\n\n  get onMetaDataArrived() {\n    return this._onMetaDataArrived;\n  }\n\n  set onMetaDataArrived(callback) {\n    this._onMetaDataArrived = callback;\n  }\n\n  get onScriptDataArrived() {\n    return this._onScriptDataArrived;\n  }\n\n  set onScriptDataArrived(callback) {\n    this._onScriptDataArrived = callback;\n  } // prototype: function(type: number, info: string): void\n\n\n  get onError() {\n    return this._onError;\n  }\n\n  set onError(callback) {\n    this._onError = callback;\n  } // prototype: function(videoTrack: any, audioTrack: any): void\n\n\n  get onDataAvailable() {\n    return this._onDataAvailable;\n  }\n\n  set onDataAvailable(callback) {\n    this._onDataAvailable = callback;\n  } // timestamp base for output samples, must be in milliseconds\n\n\n  get timestampBase() {\n    return this._timestampBase;\n  }\n\n  set timestampBase(base) {\n    this._timestampBase = base;\n  }\n\n  get overridedDuration() {\n    return this._duration;\n  } // Force-override media duration. Must be in milliseconds, int32\n\n\n  set overridedDuration(duration) {\n    this._durationOverrided = true;\n    this._duration = duration;\n    this._mediaInfo.duration = duration;\n  } // Force-override audio track present flag, boolean\n\n\n  set overridedHasAudio(hasAudio) {\n    this._hasAudioFlagOverrided = true;\n    this._hasAudio = hasAudio;\n    this._mediaInfo.hasAudio = hasAudio;\n  } // Force-override video track present flag, boolean\n\n\n  set overridedHasVideo(hasVideo) {\n    this._hasVideoFlagOverrided = true;\n    this._hasVideo = hasVideo;\n    this._mediaInfo.hasVideo = hasVideo;\n  }\n\n  resetMediaInfo() {\n    this._mediaInfo = new MediaInfo();\n  }\n\n  _isInitialMetadataDispatched() {\n    if (this._hasAudio && this._hasVideo) {\n      // both audio & video\n      return this._audioInitialMetadataDispatched && this._videoInitialMetadataDispatched;\n    }\n\n    if (this._hasAudio && !this._hasVideo) {\n      // audio only\n      return this._audioInitialMetadataDispatched;\n    }\n\n    if (!this._hasAudio && this._hasVideo) {\n      // video only\n      return this._videoInitialMetadataDispatched;\n    }\n\n    return false;\n  } // function parseChunks(chunk: ArrayBuffer, byteStart: number): number;\n\n\n  parseChunks(chunk, byteStart) {\n    if (!this._onError || !this._onMediaInfo || !this._onTrackMetadata || !this._onDataAvailable) {\n      throw new IllegalStateException('Flv: onError & onMediaInfo & onTrackMetadata & onDataAvailable callback must be specified');\n    }\n\n    let offset = 0;\n    let le = this._littleEndian;\n\n    if (byteStart === 0) {\n      // buffer with FLV header\n      if (chunk.byteLength > 13) {\n        let probeData = FLVDemuxer.probe(chunk);\n        offset = probeData.dataOffset;\n      } else {\n        return 0;\n      }\n    }\n\n    if (this._firstParse) {\n      // handle PreviousTagSize0 before Tag1\n      this._firstParse = false;\n\n      if (byteStart + offset !== this._dataOffset) {\n        Log.w(this.TAG, 'First time parsing but chunk byteStart invalid!');\n      }\n\n      let v = new DataView(chunk, offset);\n      let prevTagSize0 = v.getUint32(0, !le);\n\n      if (prevTagSize0 !== 0) {\n        Log.w(this.TAG, 'PrevTagSize0 !== 0 !!!');\n      }\n\n      offset += 4;\n    }\n\n    while (offset < chunk.byteLength) {\n      this._dispatch = true;\n      let v = new DataView(chunk, offset);\n\n      if (offset + 11 + 4 > chunk.byteLength) {\n        // data not enough for parsing an flv tag\n        break;\n      }\n\n      let tagType = v.getUint8(0);\n      let dataSize = v.getUint32(0, !le) & 0x00FFFFFF;\n\n      if (offset + 11 + dataSize + 4 > chunk.byteLength) {\n        // data not enough for parsing actual data body\n        break;\n      }\n\n      if (tagType !== 8 && tagType !== 9 && tagType !== 18) {\n        Log.w(this.TAG, \"Unsupported tag type \".concat(tagType, \", skipped\")); // consume the whole tag (skip it)\n\n        offset += 11 + dataSize + 4;\n        continue;\n      }\n\n      let ts2 = v.getUint8(4);\n      let ts1 = v.getUint8(5);\n      let ts0 = v.getUint8(6);\n      let ts3 = v.getUint8(7);\n      let timestamp = ts0 | ts1 << 8 | ts2 << 16 | ts3 << 24;\n      let streamId = v.getUint32(7, !le) & 0x00FFFFFF;\n\n      if (streamId !== 0) {\n        Log.w(this.TAG, 'Meet tag which has StreamID != 0!');\n      }\n\n      let dataOffset = offset + 11;\n\n      switch (tagType) {\n        case 8:\n          // Audio\n          this._parseAudioData(chunk, dataOffset, dataSize, timestamp);\n\n          break;\n\n        case 9:\n          // Video\n          this._parseVideoData(chunk, dataOffset, dataSize, timestamp, byteStart + offset);\n\n          break;\n\n        case 18:\n          // ScriptDataObject\n          this._parseScriptData(chunk, dataOffset, dataSize);\n\n          break;\n      }\n\n      let prevTagSize = v.getUint32(11 + dataSize, !le);\n\n      if (prevTagSize !== 11 + dataSize) {\n        Log.w(this.TAG, \"Invalid PrevTagSize \".concat(prevTagSize));\n      }\n\n      offset += 11 + dataSize + 4; // tagBody + dataSize + prevTagSize\n    } // dispatch parsed frames to consumer (typically, the remuxer)\n\n\n    if (this._isInitialMetadataDispatched()) {\n      if (this._dispatch && (this._audioTrack.length || this._videoTrack.length)) {\n        this._onDataAvailable(this._audioTrack, this._videoTrack);\n      }\n    }\n\n    return offset; // consumed bytes, just equals latest offset index\n  }\n\n  _parseScriptData(arrayBuffer, dataOffset, dataSize) {\n    let scriptData = AMF.parseScriptData(arrayBuffer, dataOffset, dataSize);\n\n    if (scriptData.hasOwnProperty('onMetaData')) {\n      if (scriptData.onMetaData == null || typeof scriptData.onMetaData !== 'object') {\n        Log.w(this.TAG, 'Invalid onMetaData structure!');\n        return;\n      }\n\n      if (this._metadata) {\n        Log.w(this.TAG, 'Found another onMetaData tag!');\n      }\n\n      this._metadata = scriptData;\n      let onMetaData = this._metadata.onMetaData;\n\n      if (this._onMetaDataArrived) {\n        this._onMetaDataArrived(Object.assign({}, onMetaData));\n      }\n\n      if (typeof onMetaData.hasAudio === 'boolean') {\n        // hasAudio\n        if (this._hasAudioFlagOverrided === false) {\n          this._hasAudio = onMetaData.hasAudio;\n          this._mediaInfo.hasAudio = this._hasAudio;\n        }\n      }\n\n      if (typeof onMetaData.hasVideo === 'boolean') {\n        // hasVideo\n        if (this._hasVideoFlagOverrided === false) {\n          this._hasVideo = onMetaData.hasVideo;\n          this._mediaInfo.hasVideo = this._hasVideo;\n        }\n      }\n\n      if (typeof onMetaData.audiodatarate === 'number') {\n        // audiodatarate\n        this._mediaInfo.audioDataRate = onMetaData.audiodatarate;\n      }\n\n      if (typeof onMetaData.videodatarate === 'number') {\n        // videodatarate\n        this._mediaInfo.videoDataRate = onMetaData.videodatarate;\n      }\n\n      if (typeof onMetaData.width === 'number') {\n        // width\n        this._mediaInfo.width = onMetaData.width;\n      }\n\n      if (typeof onMetaData.height === 'number') {\n        // height\n        this._mediaInfo.height = onMetaData.height;\n      }\n\n      if (typeof onMetaData.duration === 'number') {\n        // duration\n        if (!this._durationOverrided) {\n          let duration = Math.floor(onMetaData.duration * this._timescale);\n          this._duration = duration;\n          this._mediaInfo.duration = duration;\n        }\n      } else {\n        this._mediaInfo.duration = 0;\n      }\n\n      if (typeof onMetaData.framerate === 'number') {\n        // framerate\n        let fps_num = Math.floor(onMetaData.framerate * 1000);\n\n        if (fps_num > 0) {\n          let fps = fps_num / 1000;\n          this._referenceFrameRate.fixed = true;\n          this._referenceFrameRate.fps = fps;\n          this._referenceFrameRate.fps_num = fps_num;\n          this._referenceFrameRate.fps_den = 1000;\n          this._mediaInfo.fps = fps;\n        }\n      }\n\n      if (typeof onMetaData.keyframes === 'object') {\n        // keyframes\n        this._mediaInfo.hasKeyframesIndex = true;\n        let keyframes = onMetaData.keyframes;\n        this._mediaInfo.keyframesIndex = this._parseKeyframesIndex(keyframes);\n        onMetaData.keyframes = null; // keyframes has been extracted, remove it\n      } else {\n        this._mediaInfo.hasKeyframesIndex = false;\n      }\n\n      this._dispatch = false;\n      this._mediaInfo.metadata = onMetaData;\n      Log.v(this.TAG, 'Parsed onMetaData');\n\n      if (this._mediaInfo.isComplete()) {\n        this._onMediaInfo(this._mediaInfo);\n      }\n    }\n\n    if (Object.keys(scriptData).length > 0) {\n      if (this._onScriptDataArrived) {\n        this._onScriptDataArrived(Object.assign({}, scriptData));\n      }\n    }\n  }\n\n  _parseKeyframesIndex(keyframes) {\n    let times = [];\n    let filepositions = []; // ignore first keyframe which is actually AVC Sequence Header (AVCDecoderConfigurationRecord)\n\n    for (let i = 1; i < keyframes.times.length; i++) {\n      let time = this._timestampBase + Math.floor(keyframes.times[i] * 1000);\n      times.push(time);\n      filepositions.push(keyframes.filepositions[i]);\n    }\n\n    return {\n      times: times,\n      filepositions: filepositions\n    };\n  }\n\n  _parseAudioData(arrayBuffer, dataOffset, dataSize, tagTimestamp) {\n    if (dataSize <= 1) {\n      Log.w(this.TAG, 'Flv: Invalid audio packet, missing SoundData payload!');\n      return;\n    }\n\n    if (this._hasAudioFlagOverrided === true && this._hasAudio === false) {\n      // If hasAudio: false indicated explicitly in MediaDataSource,\n      // Ignore all the audio packets\n      return;\n    }\n\n    let le = this._littleEndian;\n    let v = new DataView(arrayBuffer, dataOffset, dataSize);\n    let soundSpec = v.getUint8(0);\n    let soundFormat = soundSpec >>> 4;\n\n    if (soundFormat !== 2 && soundFormat !== 10) {\n      // MP3 or AAC\n      this._onError(DemuxErrors.CODEC_UNSUPPORTED, 'Flv: Unsupported audio codec idx: ' + soundFormat);\n\n      return;\n    }\n\n    let soundRate = 0;\n    let soundRateIndex = (soundSpec & 12) >>> 2;\n\n    if (soundRateIndex >= 0 && soundRateIndex <= 4) {\n      soundRate = this._flvSoundRateTable[soundRateIndex];\n    } else {\n      this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: Invalid audio sample rate idx: ' + soundRateIndex);\n\n      return;\n    }\n\n    let soundSize = (soundSpec & 2) >>> 1; // unused\n\n    let soundType = soundSpec & 1;\n    let meta = this._audioMetadata;\n    let track = this._audioTrack;\n\n    if (!meta) {\n      if (this._hasAudio === false && this._hasAudioFlagOverrided === false) {\n        this._hasAudio = true;\n        this._mediaInfo.hasAudio = true;\n      } // initial metadata\n\n\n      meta = this._audioMetadata = {};\n      meta.type = 'audio';\n      meta.id = track.id;\n      meta.timescale = this._timescale;\n      meta.duration = this._duration;\n      meta.audioSampleRate = soundRate;\n      meta.channelCount = soundType === 0 ? 1 : 2;\n    }\n\n    if (soundFormat === 10) {\n      // AAC\n      let aacData = this._parseAACAudioData(arrayBuffer, dataOffset + 1, dataSize - 1);\n\n      if (aacData == undefined) {\n        return;\n      }\n\n      if (aacData.packetType === 0) {\n        // AAC sequence header (AudioSpecificConfig)\n        if (meta.config) {\n          Log.w(this.TAG, 'Found another AudioSpecificConfig!');\n        }\n\n        let misc = aacData.data;\n        meta.audioSampleRate = misc.samplingRate;\n        meta.channelCount = misc.channelCount;\n        meta.codec = misc.codec;\n        meta.originalCodec = misc.originalCodec;\n        meta.config = misc.config; // The decode result of an aac sample is 1024 PCM samples\n\n        meta.refSampleDuration = 1024 / meta.audioSampleRate * meta.timescale;\n        Log.v(this.TAG, 'Parsed AudioSpecificConfig');\n\n        if (this._isInitialMetadataDispatched()) {\n          // Non-initial metadata, force dispatch (or flush) parsed frames to remuxer\n          if (this._dispatch && (this._audioTrack.length || this._videoTrack.length)) {\n            this._onDataAvailable(this._audioTrack, this._videoTrack);\n          }\n        } else {\n          this._audioInitialMetadataDispatched = true;\n        } // then notify new metadata\n\n\n        this._dispatch = false;\n\n        this._onTrackMetadata('audio', meta);\n\n        let mi = this._mediaInfo;\n        mi.audioCodec = meta.originalCodec;\n        mi.audioSampleRate = meta.audioSampleRate;\n        mi.audioChannelCount = meta.channelCount;\n\n        if (mi.hasVideo) {\n          if (mi.videoCodec != null) {\n            mi.mimeType = 'video/x-flv; codecs=\"' + mi.videoCodec + ',' + mi.audioCodec + '\"';\n          }\n        } else {\n          mi.mimeType = 'video/x-flv; codecs=\"' + mi.audioCodec + '\"';\n        }\n\n        if (mi.isComplete()) {\n          this._onMediaInfo(mi);\n        }\n      } else if (aacData.packetType === 1) {\n        // AAC raw frame data\n        let dts = this._timestampBase + tagTimestamp;\n        let aacSample = {\n          unit: aacData.data,\n          length: aacData.data.byteLength,\n          dts: dts,\n          pts: dts\n        };\n        track.samples.push(aacSample);\n        track.length += aacData.data.length;\n      } else {\n        Log.e(this.TAG, \"Flv: Unsupported AAC data type \".concat(aacData.packetType));\n      }\n    } else if (soundFormat === 2) {\n      // MP3\n      if (!meta.codec) {\n        // We need metadata for mp3 audio track, extract info from frame header\n        let misc = this._parseMP3AudioData(arrayBuffer, dataOffset + 1, dataSize - 1, true);\n\n        if (misc == undefined) {\n          return;\n        }\n\n        meta.audioSampleRate = misc.samplingRate;\n        meta.channelCount = misc.channelCount;\n        meta.codec = misc.codec;\n        meta.originalCodec = misc.originalCodec; // The decode result of an mp3 sample is 1152 PCM samples\n\n        meta.refSampleDuration = 1152 / meta.audioSampleRate * meta.timescale;\n        Log.v(this.TAG, 'Parsed MPEG Audio Frame Header');\n        this._audioInitialMetadataDispatched = true;\n\n        this._onTrackMetadata('audio', meta);\n\n        let mi = this._mediaInfo;\n        mi.audioCodec = meta.codec;\n        mi.audioSampleRate = meta.audioSampleRate;\n        mi.audioChannelCount = meta.channelCount;\n        mi.audioDataRate = misc.bitRate;\n\n        if (mi.hasVideo) {\n          if (mi.videoCodec != null) {\n            mi.mimeType = 'video/x-flv; codecs=\"' + mi.videoCodec + ',' + mi.audioCodec + '\"';\n          }\n        } else {\n          mi.mimeType = 'video/x-flv; codecs=\"' + mi.audioCodec + '\"';\n        }\n\n        if (mi.isComplete()) {\n          this._onMediaInfo(mi);\n        }\n      } // This packet is always a valid audio packet, extract it\n\n\n      let data = this._parseMP3AudioData(arrayBuffer, dataOffset + 1, dataSize - 1, false);\n\n      if (data == undefined) {\n        return;\n      }\n\n      let dts = this._timestampBase + tagTimestamp;\n      let mp3Sample = {\n        unit: data,\n        length: data.byteLength,\n        dts: dts,\n        pts: dts\n      };\n      track.samples.push(mp3Sample);\n      track.length += data.length;\n    }\n  }\n\n  _parseAACAudioData(arrayBuffer, dataOffset, dataSize) {\n    if (dataSize <= 1) {\n      Log.w(this.TAG, 'Flv: Invalid AAC packet, missing AACPacketType or/and Data!');\n      return;\n    }\n\n    let result = {};\n    let array = new Uint8Array(arrayBuffer, dataOffset, dataSize);\n    result.packetType = array[0];\n\n    if (array[0] === 0) {\n      result.data = this._parseAACAudioSpecificConfig(arrayBuffer, dataOffset + 1, dataSize - 1);\n    } else {\n      result.data = array.subarray(1);\n    }\n\n    return result;\n  }\n\n  _parseAACAudioSpecificConfig(arrayBuffer, dataOffset, dataSize) {\n    let array = new Uint8Array(arrayBuffer, dataOffset, dataSize);\n    let config = null;\n    /* Audio Object Type:\n       0: Null\n       1: AAC Main\n       2: AAC LC\n       3: AAC SSR (Scalable Sample Rate)\n       4: AAC LTP (Long Term Prediction)\n       5: HE-AAC / SBR (Spectral Band Replication)\n       6: AAC Scalable\n    */\n\n    let audioObjectType = 0;\n    let originalAudioObjectType = 0;\n    let audioExtensionObjectType = null;\n    let samplingIndex = 0;\n    let extensionSamplingIndex = null; // 5 bits\n\n    audioObjectType = originalAudioObjectType = array[0] >>> 3; // 4 bits\n\n    samplingIndex = (array[0] & 0x07) << 1 | array[1] >>> 7;\n\n    if (samplingIndex < 0 || samplingIndex >= this._mpegSamplingRates.length) {\n      this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: AAC invalid sampling frequency index!');\n\n      return;\n    }\n\n    let samplingFrequence = this._mpegSamplingRates[samplingIndex]; // 4 bits\n\n    let channelConfig = (array[1] & 0x78) >>> 3;\n\n    if (channelConfig < 0 || channelConfig >= 8) {\n      this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: AAC invalid channel configuration');\n\n      return;\n    }\n\n    if (audioObjectType === 5) {\n      // HE-AAC?\n      // 4 bits\n      extensionSamplingIndex = (array[1] & 0x07) << 1 | array[2] >>> 7; // 5 bits\n\n      audioExtensionObjectType = (array[2] & 0x7C) >>> 2;\n    } // workarounds for various browsers\n\n\n    let userAgent = self.navigator.userAgent.toLowerCase();\n\n    if (userAgent.indexOf('firefox') !== -1) {\n      // firefox: use SBR (HE-AAC) if freq less than 24kHz\n      if (samplingIndex >= 6) {\n        audioObjectType = 5;\n        config = new Array(4);\n        extensionSamplingIndex = samplingIndex - 3;\n      } else {\n        // use LC-AAC\n        audioObjectType = 2;\n        config = new Array(2);\n        extensionSamplingIndex = samplingIndex;\n      }\n    } else if (userAgent.indexOf('android') !== -1) {\n      // android: always use LC-AAC\n      audioObjectType = 2;\n      config = new Array(2);\n      extensionSamplingIndex = samplingIndex;\n    } else {\n      // for other browsers, e.g. chrome...\n      // Always use HE-AAC to make it easier to switch aac codec profile\n      audioObjectType = 5;\n      extensionSamplingIndex = samplingIndex;\n      config = new Array(4);\n\n      if (samplingIndex >= 6) {\n        extensionSamplingIndex = samplingIndex - 3;\n      } else if (channelConfig === 1) {\n        // Mono channel\n        audioObjectType = 2;\n        config = new Array(2);\n        extensionSamplingIndex = samplingIndex;\n      }\n    }\n\n    config[0] = audioObjectType << 3;\n    config[0] |= (samplingIndex & 0x0F) >>> 1;\n    config[1] = (samplingIndex & 0x0F) << 7;\n    config[1] |= (channelConfig & 0x0F) << 3;\n\n    if (audioObjectType === 5) {\n      config[1] |= (extensionSamplingIndex & 0x0F) >>> 1;\n      config[2] = (extensionSamplingIndex & 0x01) << 7; // extended audio object type: force to 2 (LC-AAC)\n\n      config[2] |= 2 << 2;\n      config[3] = 0;\n    }\n\n    return {\n      config: config,\n      samplingRate: samplingFrequence,\n      channelCount: channelConfig,\n      codec: 'mp4a.40.' + audioObjectType,\n      originalCodec: 'mp4a.40.' + originalAudioObjectType\n    };\n  }\n\n  _parseMP3AudioData(arrayBuffer, dataOffset, dataSize, requestHeader) {\n    if (dataSize < 4) {\n      Log.w(this.TAG, 'Flv: Invalid MP3 packet, header missing!');\n      return;\n    }\n\n    let le = this._littleEndian;\n    let array = new Uint8Array(arrayBuffer, dataOffset, dataSize);\n    let result = null;\n\n    if (requestHeader) {\n      if (array[0] !== 0xFF) {\n        return;\n      }\n\n      let ver = array[1] >>> 3 & 0x03;\n      let layer = (array[1] & 0x06) >> 1;\n      let bitrate_index = (array[2] & 0xF0) >>> 4;\n      let sampling_freq_index = (array[2] & 0x0C) >>> 2;\n      let channel_mode = array[3] >>> 6 & 0x03;\n      let channel_count = channel_mode !== 3 ? 2 : 1;\n      let sample_rate = 0;\n      let bit_rate = 0;\n      let object_type = 34; // Layer-3, listed in MPEG-4 Audio Object Types\n\n      let codec = 'mp3';\n\n      switch (ver) {\n        case 0:\n          // MPEG 2.5\n          sample_rate = this._mpegAudioV25SampleRateTable[sampling_freq_index];\n          break;\n\n        case 2:\n          // MPEG 2\n          sample_rate = this._mpegAudioV20SampleRateTable[sampling_freq_index];\n          break;\n\n        case 3:\n          // MPEG 1\n          sample_rate = this._mpegAudioV10SampleRateTable[sampling_freq_index];\n          break;\n      }\n\n      switch (layer) {\n        case 1:\n          // Layer 3\n          object_type = 34;\n\n          if (bitrate_index < this._mpegAudioL3BitRateTable.length) {\n            bit_rate = this._mpegAudioL3BitRateTable[bitrate_index];\n          }\n\n          break;\n\n        case 2:\n          // Layer 2\n          object_type = 33;\n\n          if (bitrate_index < this._mpegAudioL2BitRateTable.length) {\n            bit_rate = this._mpegAudioL2BitRateTable[bitrate_index];\n          }\n\n          break;\n\n        case 3:\n          // Layer 1\n          object_type = 32;\n\n          if (bitrate_index < this._mpegAudioL1BitRateTable.length) {\n            bit_rate = this._mpegAudioL1BitRateTable[bitrate_index];\n          }\n\n          break;\n      }\n\n      result = {\n        bitRate: bit_rate,\n        samplingRate: sample_rate,\n        channelCount: channel_count,\n        codec: codec,\n        originalCodec: codec\n      };\n    } else {\n      result = array;\n    }\n\n    return result;\n  }\n\n  _parseVideoData(arrayBuffer, dataOffset, dataSize, tagTimestamp, tagPosition) {\n    if (dataSize <= 1) {\n      Log.w(this.TAG, 'Flv: Invalid video packet, missing VideoData payload!');\n      return;\n    }\n\n    if (this._hasVideoFlagOverrided === true && this._hasVideo === false) {\n      // If hasVideo: false indicated explicitly in MediaDataSource,\n      // Ignore all the video packets\n      return;\n    }\n\n    let spec = new Uint8Array(arrayBuffer, dataOffset, dataSize)[0];\n    let frameType = (spec & 240) >>> 4;\n    let codecId = spec & 15;\n\n    if (codecId !== 7) {\n      this._onError(DemuxErrors.CODEC_UNSUPPORTED, \"Flv: Unsupported codec in video frame: \".concat(codecId));\n\n      return;\n    }\n\n    this._parseAVCVideoPacket(arrayBuffer, dataOffset + 1, dataSize - 1, tagTimestamp, tagPosition, frameType);\n  }\n\n  _parseAVCVideoPacket(arrayBuffer, dataOffset, dataSize, tagTimestamp, tagPosition, frameType) {\n    if (dataSize < 4) {\n      Log.w(this.TAG, 'Flv: Invalid AVC packet, missing AVCPacketType or/and CompositionTime');\n      return;\n    }\n\n    let le = this._littleEndian;\n    let v = new DataView(arrayBuffer, dataOffset, dataSize);\n    let packetType = v.getUint8(0);\n    let cts_unsigned = v.getUint32(0, !le) & 0x00FFFFFF;\n    let cts = cts_unsigned << 8 >> 8; // convert to 24-bit signed int\n\n    if (packetType === 0) {\n      // AVCDecoderConfigurationRecord\n      this._parseAVCDecoderConfigurationRecord(arrayBuffer, dataOffset + 4, dataSize - 4);\n    } else if (packetType === 1) {\n      // One or more Nalus\n      this._parseAVCVideoData(arrayBuffer, dataOffset + 4, dataSize - 4, tagTimestamp, tagPosition, frameType, cts);\n    } else if (packetType === 2) {// empty, AVC end of sequence\n    } else {\n      this._onError(DemuxErrors.FORMAT_ERROR, \"Flv: Invalid video packet type \".concat(packetType));\n\n      return;\n    }\n  }\n\n  _parseAVCDecoderConfigurationRecord(arrayBuffer, dataOffset, dataSize) {\n    if (dataSize < 7) {\n      Log.w(this.TAG, 'Flv: Invalid AVCDecoderConfigurationRecord, lack of data!');\n      return;\n    }\n\n    let meta = this._videoMetadata;\n    let track = this._videoTrack;\n    let le = this._littleEndian;\n    let v = new DataView(arrayBuffer, dataOffset, dataSize);\n\n    if (!meta) {\n      if (this._hasVideo === false && this._hasVideoFlagOverrided === false) {\n        this._hasVideo = true;\n        this._mediaInfo.hasVideo = true;\n      }\n\n      meta = this._videoMetadata = {};\n      meta.type = 'video';\n      meta.id = track.id;\n      meta.timescale = this._timescale;\n      meta.duration = this._duration;\n    } else {\n      if (typeof meta.avcc !== 'undefined') {\n        Log.w(this.TAG, 'Found another AVCDecoderConfigurationRecord!');\n      }\n    }\n\n    let version = v.getUint8(0); // configurationVersion\n\n    let avcProfile = v.getUint8(1); // avcProfileIndication\n\n    let profileCompatibility = v.getUint8(2); // profile_compatibility\n\n    let avcLevel = v.getUint8(3); // AVCLevelIndication\n\n    if (version !== 1 || avcProfile === 0) {\n      this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: Invalid AVCDecoderConfigurationRecord');\n\n      return;\n    }\n\n    this._naluLengthSize = (v.getUint8(4) & 3) + 1; // lengthSizeMinusOne\n\n    if (this._naluLengthSize !== 3 && this._naluLengthSize !== 4) {\n      // holy shit!!!\n      this._onError(DemuxErrors.FORMAT_ERROR, \"Flv: Strange NaluLengthSizeMinusOne: \".concat(this._naluLengthSize - 1));\n\n      return;\n    }\n\n    let spsCount = v.getUint8(5) & 31; // numOfSequenceParameterSets\n\n    if (spsCount === 0) {\n      this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: Invalid AVCDecoderConfigurationRecord: No SPS');\n\n      return;\n    } else if (spsCount > 1) {\n      Log.w(this.TAG, \"Flv: Strange AVCDecoderConfigurationRecord: SPS Count = \".concat(spsCount));\n    }\n\n    let offset = 6;\n\n    for (let i = 0; i < spsCount; i++) {\n      let len = v.getUint16(offset, !le); // sequenceParameterSetLength\n\n      offset += 2;\n\n      if (len === 0) {\n        continue;\n      } // Notice: Nalu without startcode header (00 00 00 01)\n\n\n      let sps = new Uint8Array(arrayBuffer, dataOffset + offset, len);\n      offset += len;\n      let config = SPSParser.parseSPS(sps);\n\n      if (i !== 0) {\n        // ignore other sps's config\n        continue;\n      }\n\n      meta.codecWidth = config.codec_size.width;\n      meta.codecHeight = config.codec_size.height;\n      meta.presentWidth = config.present_size.width;\n      meta.presentHeight = config.present_size.height;\n      meta.profile = config.profile_string;\n      meta.level = config.level_string;\n      meta.bitDepth = config.bit_depth;\n      meta.chromaFormat = config.chroma_format;\n      meta.sarRatio = config.sar_ratio;\n      meta.frameRate = config.frame_rate;\n\n      if (config.frame_rate.fixed === false || config.frame_rate.fps_num === 0 || config.frame_rate.fps_den === 0) {\n        meta.frameRate = this._referenceFrameRate;\n      }\n\n      let fps_den = meta.frameRate.fps_den;\n      let fps_num = meta.frameRate.fps_num;\n      meta.refSampleDuration = meta.timescale * (fps_den / fps_num);\n      let codecArray = sps.subarray(1, 4);\n      let codecString = 'avc1.';\n\n      for (let j = 0; j < 3; j++) {\n        let h = codecArray[j].toString(16);\n\n        if (h.length < 2) {\n          h = '0' + h;\n        }\n\n        codecString += h;\n      }\n\n      meta.codec = codecString;\n      let mi = this._mediaInfo;\n      mi.width = meta.codecWidth;\n      mi.height = meta.codecHeight;\n      mi.fps = meta.frameRate.fps;\n      mi.profile = meta.profile;\n      mi.level = meta.level;\n      mi.refFrames = config.ref_frames;\n      mi.chromaFormat = config.chroma_format_string;\n      mi.sarNum = meta.sarRatio.width;\n      mi.sarDen = meta.sarRatio.height;\n      mi.videoCodec = codecString;\n\n      if (mi.hasAudio) {\n        if (mi.audioCodec != null) {\n          mi.mimeType = 'video/x-flv; codecs=\"' + mi.videoCodec + ',' + mi.audioCodec + '\"';\n        }\n      } else {\n        mi.mimeType = 'video/x-flv; codecs=\"' + mi.videoCodec + '\"';\n      }\n\n      if (mi.isComplete()) {\n        this._onMediaInfo(mi);\n      }\n    }\n\n    let ppsCount = v.getUint8(offset); // numOfPictureParameterSets\n\n    if (ppsCount === 0) {\n      this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: Invalid AVCDecoderConfigurationRecord: No PPS');\n\n      return;\n    } else if (ppsCount > 1) {\n      Log.w(this.TAG, \"Flv: Strange AVCDecoderConfigurationRecord: PPS Count = \".concat(ppsCount));\n    }\n\n    offset++;\n\n    for (let i = 0; i < ppsCount; i++) {\n      let len = v.getUint16(offset, !le); // pictureParameterSetLength\n\n      offset += 2;\n\n      if (len === 0) {\n        continue;\n      } // pps is useless for extracting video information\n\n\n      offset += len;\n    }\n\n    meta.avcc = new Uint8Array(dataSize);\n    meta.avcc.set(new Uint8Array(arrayBuffer, dataOffset, dataSize), 0);\n    Log.v(this.TAG, 'Parsed AVCDecoderConfigurationRecord');\n\n    if (this._isInitialMetadataDispatched()) {\n      // flush parsed frames\n      if (this._dispatch && (this._audioTrack.length || this._videoTrack.length)) {\n        this._onDataAvailable(this._audioTrack, this._videoTrack);\n      }\n    } else {\n      this._videoInitialMetadataDispatched = true;\n    } // notify new metadata\n\n\n    this._dispatch = false;\n\n    this._onTrackMetadata('video', meta);\n  }\n\n  _parseAVCVideoData(arrayBuffer, dataOffset, dataSize, tagTimestamp, tagPosition, frameType, cts) {\n    let le = this._littleEndian;\n    let v = new DataView(arrayBuffer, dataOffset, dataSize);\n    let units = [],\n        length = 0;\n    let offset = 0;\n    const lengthSize = this._naluLengthSize;\n    let dts = this._timestampBase + tagTimestamp;\n    let keyframe = frameType === 1; // from FLV Frame Type constants\n\n    while (offset < dataSize) {\n      if (offset + 4 >= dataSize) {\n        Log.w(this.TAG, \"Malformed Nalu near timestamp \".concat(dts, \", offset = \").concat(offset, \", dataSize = \").concat(dataSize));\n        break; // data not enough for next Nalu\n      } // Nalu with length-header (AVC1)\n\n\n      let naluSize = v.getUint32(offset, !le); // Big-Endian read\n\n      if (lengthSize === 3) {\n        naluSize >>>= 8;\n      }\n\n      if (naluSize > dataSize - lengthSize) {\n        Log.w(this.TAG, \"Malformed Nalus near timestamp \".concat(dts, \", NaluSize > DataSize!\"));\n        return;\n      }\n\n      let unitType = v.getUint8(offset + lengthSize) & 0x1F;\n\n      if (unitType === 5) {\n        // IDR\n        keyframe = true;\n      }\n\n      let data = new Uint8Array(arrayBuffer, dataOffset + offset, lengthSize + naluSize);\n      let unit = {\n        type: unitType,\n        data: data\n      };\n      units.push(unit);\n      length += data.byteLength;\n      offset += lengthSize + naluSize;\n    }\n\n    if (units.length) {\n      let track = this._videoTrack;\n      let avcSample = {\n        units: units,\n        length: length,\n        isKeyframe: keyframe,\n        dts: dts,\n        cts: cts,\n        pts: dts + cts\n      };\n\n      if (keyframe) {\n        avcSample.fileposition = tagPosition;\n      }\n\n      track.samples.push(avcSample);\n      track.length += length;\n    }\n  }\n\n}\n\nexport default FLVDemuxer;","map":null,"metadata":{},"sourceType":"module"}