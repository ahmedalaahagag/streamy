{"ast":null,"code":"/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport Log from '../utils/logger.js';\nimport { BaseLoader, LoaderStatus, LoaderErrors } from './loader.js';\nimport { RuntimeException } from '../utils/exception.js'; // For FLV over WebSocket live stream\n\nclass WebSocketLoader extends BaseLoader {\n  static isSupported() {\n    try {\n      return typeof self.WebSocket !== 'undefined';\n    } catch (e) {\n      return false;\n    }\n  }\n\n  constructor() {\n    super('websocket-loader');\n    this.TAG = 'WebSocketLoader';\n    this._needStash = true;\n    this._ws = null;\n    this._requestAbort = false;\n    this._receivedLength = 0;\n  }\n\n  destroy() {\n    if (this._ws) {\n      this.abort();\n    }\n\n    super.destroy();\n  }\n\n  open(dataSource) {\n    try {\n      let ws = this._ws = new self.WebSocket(dataSource.url);\n      ws.binaryType = 'arraybuffer';\n      ws.onopen = this._onWebSocketOpen.bind(this);\n      ws.onclose = this._onWebSocketClose.bind(this);\n      ws.onmessage = this._onWebSocketMessage.bind(this);\n      ws.onerror = this._onWebSocketError.bind(this);\n      this._status = LoaderStatus.kConnecting;\n    } catch (e) {\n      this._status = LoaderStatus.kError;\n      let info = {\n        code: e.code,\n        msg: e.message\n      };\n\n      if (this._onError) {\n        this._onError(LoaderErrors.EXCEPTION, info);\n      } else {\n        throw new RuntimeException(info.msg);\n      }\n    }\n  }\n\n  abort() {\n    let ws = this._ws;\n\n    if (ws && (ws.readyState === 0 || ws.readyState === 1)) {\n      // CONNECTING || OPEN\n      this._requestAbort = true;\n      ws.close();\n    }\n\n    this._ws = null;\n    this._status = LoaderStatus.kComplete;\n  }\n\n  _onWebSocketOpen(e) {\n    this._status = LoaderStatus.kBuffering;\n  }\n\n  _onWebSocketClose(e) {\n    if (this._requestAbort === true) {\n      this._requestAbort = false;\n      return;\n    }\n\n    this._status = LoaderStatus.kComplete;\n\n    if (this._onComplete) {\n      this._onComplete(0, this._receivedLength - 1);\n    }\n  }\n\n  _onWebSocketMessage(e) {\n    if (e.data instanceof ArrayBuffer) {\n      this._dispatchArrayBuffer(e.data);\n    } else if (e.data instanceof Blob) {\n      let reader = new FileReader();\n\n      reader.onload = () => {\n        this._dispatchArrayBuffer(reader.result);\n      };\n\n      reader.readAsArrayBuffer(e.data);\n    } else {\n      this._status = LoaderStatus.kError;\n      let info = {\n        code: -1,\n        msg: 'Unsupported WebSocket message type: ' + e.data.constructor.name\n      };\n\n      if (this._onError) {\n        this._onError(LoaderErrors.EXCEPTION, info);\n      } else {\n        throw new RuntimeException(info.msg);\n      }\n    }\n  }\n\n  _dispatchArrayBuffer(arraybuffer) {\n    let chunk = arraybuffer;\n    let byteStart = this._receivedLength;\n    this._receivedLength += chunk.byteLength;\n\n    if (this._onDataArrival) {\n      this._onDataArrival(chunk, byteStart, this._receivedLength);\n    }\n  }\n\n  _onWebSocketError(e) {\n    this._status = LoaderStatus.kError;\n    let info = {\n      code: e.code,\n      msg: e.message\n    };\n\n    if (this._onError) {\n      this._onError(LoaderErrors.EXCEPTION, info);\n    } else {\n      throw new RuntimeException(info.msg);\n    }\n  }\n\n}\n\nexport default WebSocketLoader;","map":null,"metadata":{},"sourceType":"module"}