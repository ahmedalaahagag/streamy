{"ast":null,"code":"/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport EventEmitter from 'events';\nimport Log from '../utils/logger.js';\nimport Browser from '../utils/browser.js';\nimport MSEEvents from './mse-events.js';\nimport { SampleInfo, IDRSampleList } from './media-segment-info.js';\nimport { IllegalStateException } from '../utils/exception.js'; // Media Source Extensions controller\n\nclass MSEController {\n  constructor(config) {\n    this.TAG = 'MSEController';\n    this._config = config;\n    this._emitter = new EventEmitter();\n\n    if (this._config.isLive && this._config.autoCleanupSourceBuffer == undefined) {\n      // For live stream, do auto cleanup by default\n      this._config.autoCleanupSourceBuffer = true;\n    }\n\n    this.e = {\n      onSourceOpen: this._onSourceOpen.bind(this),\n      onSourceEnded: this._onSourceEnded.bind(this),\n      onSourceClose: this._onSourceClose.bind(this),\n      onSourceBufferError: this._onSourceBufferError.bind(this),\n      onSourceBufferUpdateEnd: this._onSourceBufferUpdateEnd.bind(this)\n    };\n    this._mediaSource = null;\n    this._mediaSourceObjectURL = null;\n    this._mediaElement = null;\n    this._isBufferFull = false;\n    this._hasPendingEos = false;\n    this._requireSetMediaDuration = false;\n    this._pendingMediaDuration = 0;\n    this._pendingSourceBufferInit = [];\n    this._mimeTypes = {\n      video: null,\n      audio: null\n    };\n    this._sourceBuffers = {\n      video: null,\n      audio: null\n    };\n    this._lastInitSegments = {\n      video: null,\n      audio: null\n    };\n    this._pendingSegments = {\n      video: [],\n      audio: []\n    };\n    this._pendingRemoveRanges = {\n      video: [],\n      audio: []\n    };\n    this._idrList = new IDRSampleList();\n  }\n\n  destroy() {\n    if (this._mediaElement || this._mediaSource) {\n      this.detachMediaElement();\n    }\n\n    this.e = null;\n\n    this._emitter.removeAllListeners();\n\n    this._emitter = null;\n  }\n\n  on(event, listener) {\n    this._emitter.addListener(event, listener);\n  }\n\n  off(event, listener) {\n    this._emitter.removeListener(event, listener);\n  }\n\n  attachMediaElement(mediaElement) {\n    if (this._mediaSource) {\n      throw new IllegalStateException('MediaSource has been attached to an HTMLMediaElement!');\n    }\n\n    let ms = this._mediaSource = new window.MediaSource();\n    ms.addEventListener('sourceopen', this.e.onSourceOpen);\n    ms.addEventListener('sourceended', this.e.onSourceEnded);\n    ms.addEventListener('sourceclose', this.e.onSourceClose);\n    this._mediaElement = mediaElement;\n    this._mediaSourceObjectURL = window.URL.createObjectURL(this._mediaSource);\n    mediaElement.src = this._mediaSourceObjectURL;\n  }\n\n  detachMediaElement() {\n    if (this._mediaSource) {\n      let ms = this._mediaSource;\n\n      for (let type in this._sourceBuffers) {\n        // pending segments should be discard\n        let ps = this._pendingSegments[type];\n        ps.splice(0, ps.length);\n        this._pendingSegments[type] = null;\n        this._pendingRemoveRanges[type] = null;\n        this._lastInitSegments[type] = null; // remove all sourcebuffers\n\n        let sb = this._sourceBuffers[type];\n\n        if (sb) {\n          if (ms.readyState !== 'closed') {\n            // ms edge can throw an error: Unexpected call to method or property access\n            try {\n              ms.removeSourceBuffer(sb);\n            } catch (error) {\n              Log.e(this.TAG, error.message);\n            }\n\n            sb.removeEventListener('error', this.e.onSourceBufferError);\n            sb.removeEventListener('updateend', this.e.onSourceBufferUpdateEnd);\n          }\n\n          this._mimeTypes[type] = null;\n          this._sourceBuffers[type] = null;\n        }\n      }\n\n      if (ms.readyState === 'open') {\n        try {\n          ms.endOfStream();\n        } catch (error) {\n          Log.e(this.TAG, error.message);\n        }\n      }\n\n      ms.removeEventListener('sourceopen', this.e.onSourceOpen);\n      ms.removeEventListener('sourceended', this.e.onSourceEnded);\n      ms.removeEventListener('sourceclose', this.e.onSourceClose);\n      this._pendingSourceBufferInit = [];\n      this._isBufferFull = false;\n\n      this._idrList.clear();\n\n      this._mediaSource = null;\n    }\n\n    if (this._mediaElement) {\n      this._mediaElement.src = '';\n\n      this._mediaElement.removeAttribute('src');\n\n      this._mediaElement = null;\n    }\n\n    if (this._mediaSourceObjectURL) {\n      window.URL.revokeObjectURL(this._mediaSourceObjectURL);\n      this._mediaSourceObjectURL = null;\n    }\n  }\n\n  appendInitSegment(initSegment, deferred) {\n    if (!this._mediaSource || this._mediaSource.readyState !== 'open') {\n      // sourcebuffer creation requires mediaSource.readyState === 'open'\n      // so we defer the sourcebuffer creation, until sourceopen event triggered\n      this._pendingSourceBufferInit.push(initSegment); // make sure that this InitSegment is in the front of pending segments queue\n\n\n      this._pendingSegments[initSegment.type].push(initSegment);\n\n      return;\n    }\n\n    let is = initSegment;\n    let mimeType = \"\".concat(is.container);\n\n    if (is.codec && is.codec.length > 0) {\n      mimeType += \";codecs=\".concat(is.codec);\n    }\n\n    let firstInitSegment = false;\n    Log.v(this.TAG, 'Received Initialization Segment, mimeType: ' + mimeType);\n    this._lastInitSegments[is.type] = is;\n\n    if (mimeType !== this._mimeTypes[is.type]) {\n      if (!this._mimeTypes[is.type]) {\n        // empty, first chance create sourcebuffer\n        firstInitSegment = true;\n\n        try {\n          let sb = this._sourceBuffers[is.type] = this._mediaSource.addSourceBuffer(mimeType);\n\n          sb.addEventListener('error', this.e.onSourceBufferError);\n          sb.addEventListener('updateend', this.e.onSourceBufferUpdateEnd);\n        } catch (error) {\n          Log.e(this.TAG, error.message);\n\n          this._emitter.emit(MSEEvents.ERROR, {\n            code: error.code,\n            msg: error.message\n          });\n\n          return;\n        }\n      } else {\n        Log.v(this.TAG, \"Notice: \".concat(is.type, \" mimeType changed, origin: \").concat(this._mimeTypes[is.type], \", target: \").concat(mimeType));\n      }\n\n      this._mimeTypes[is.type] = mimeType;\n    }\n\n    if (!deferred) {\n      // deferred means this InitSegment has been pushed to pendingSegments queue\n      this._pendingSegments[is.type].push(is);\n    }\n\n    if (!firstInitSegment) {\n      // append immediately only if init segment in subsequence\n      if (this._sourceBuffers[is.type] && !this._sourceBuffers[is.type].updating) {\n        this._doAppendSegments();\n      }\n    }\n\n    if (Browser.safari && is.container === 'audio/mpeg' && is.mediaDuration > 0) {\n      // 'audio/mpeg' track under Safari may cause MediaElement's duration to be NaN\n      // Manually correct MediaSource.duration to make progress bar seekable, and report right duration\n      this._requireSetMediaDuration = true;\n      this._pendingMediaDuration = is.mediaDuration / 1000; // in seconds\n\n      this._updateMediaSourceDuration();\n    }\n  }\n\n  appendMediaSegment(mediaSegment) {\n    let ms = mediaSegment;\n\n    this._pendingSegments[ms.type].push(ms);\n\n    if (this._config.autoCleanupSourceBuffer && this._needCleanupSourceBuffer()) {\n      this._doCleanupSourceBuffer();\n    }\n\n    let sb = this._sourceBuffers[ms.type];\n\n    if (sb && !sb.updating && !this._hasPendingRemoveRanges()) {\n      this._doAppendSegments();\n    }\n  }\n\n  seek(seconds) {\n    // remove all appended buffers\n    for (let type in this._sourceBuffers) {\n      if (!this._sourceBuffers[type]) {\n        continue;\n      } // abort current buffer append algorithm\n\n\n      let sb = this._sourceBuffers[type];\n\n      if (this._mediaSource.readyState === 'open') {\n        try {\n          // If range removal algorithm is running, InvalidStateError will be throwed\n          // Ignore it.\n          sb.abort();\n        } catch (error) {\n          Log.e(this.TAG, error.message);\n        }\n      } // IDRList should be clear\n\n\n      this._idrList.clear(); // pending segments should be discard\n\n\n      let ps = this._pendingSegments[type];\n      ps.splice(0, ps.length);\n\n      if (this._mediaSource.readyState === 'closed') {\n        // Parent MediaSource object has been detached from HTMLMediaElement\n        continue;\n      } // record ranges to be remove from SourceBuffer\n\n\n      for (let i = 0; i < sb.buffered.length; i++) {\n        let start = sb.buffered.start(i);\n        let end = sb.buffered.end(i);\n\n        this._pendingRemoveRanges[type].push({\n          start,\n          end\n        });\n      } // if sb is not updating, let's remove ranges now!\n\n\n      if (!sb.updating) {\n        this._doRemoveRanges();\n      } // Safari 10 may get InvalidStateError in the later appendBuffer() after SourceBuffer.remove() call\n      // Internal parser's state may be invalid at this time. Re-append last InitSegment to workaround.\n      // Related issue: https://bugs.webkit.org/show_bug.cgi?id=159230\n\n\n      if (Browser.safari) {\n        let lastInitSegment = this._lastInitSegments[type];\n\n        if (lastInitSegment) {\n          this._pendingSegments[type].push(lastInitSegment);\n\n          if (!sb.updating) {\n            this._doAppendSegments();\n          }\n        }\n      }\n    }\n  }\n\n  endOfStream() {\n    let ms = this._mediaSource;\n    let sb = this._sourceBuffers;\n\n    if (!ms || ms.readyState !== 'open') {\n      if (ms && ms.readyState === 'closed' && this._hasPendingSegments()) {\n        // If MediaSource hasn't turned into open state, and there're pending segments\n        // Mark pending endOfStream, defer call until all pending segments appended complete\n        this._hasPendingEos = true;\n      }\n\n      return;\n    }\n\n    if (sb.video && sb.video.updating || sb.audio && sb.audio.updating) {\n      // If any sourcebuffer is updating, defer endOfStream operation\n      // See _onSourceBufferUpdateEnd()\n      this._hasPendingEos = true;\n    } else {\n      this._hasPendingEos = false; // Notify media data loading complete\n      // This is helpful for correcting total duration to match last media segment\n      // Otherwise MediaElement's ended event may not be triggered\n\n      ms.endOfStream();\n    }\n  }\n\n  getNearestKeyframe(dts) {\n    return this._idrList.getLastSyncPointBeforeDts(dts);\n  }\n\n  _needCleanupSourceBuffer() {\n    if (!this._config.autoCleanupSourceBuffer) {\n      return false;\n    }\n\n    let currentTime = this._mediaElement.currentTime;\n\n    for (let type in this._sourceBuffers) {\n      let sb = this._sourceBuffers[type];\n\n      if (sb) {\n        let buffered = sb.buffered;\n\n        if (buffered.length >= 1) {\n          if (currentTime - buffered.start(0) >= this._config.autoCleanupMaxBackwardDuration) {\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n  _doCleanupSourceBuffer() {\n    let currentTime = this._mediaElement.currentTime;\n\n    for (let type in this._sourceBuffers) {\n      let sb = this._sourceBuffers[type];\n\n      if (sb) {\n        let buffered = sb.buffered;\n        let doRemove = false;\n\n        for (let i = 0; i < buffered.length; i++) {\n          let start = buffered.start(i);\n          let end = buffered.end(i);\n\n          if (start <= currentTime && currentTime < end + 3) {\n            // padding 3 seconds\n            if (currentTime - start >= this._config.autoCleanupMaxBackwardDuration) {\n              doRemove = true;\n              let removeEnd = currentTime - this._config.autoCleanupMinBackwardDuration;\n\n              this._pendingRemoveRanges[type].push({\n                start: start,\n                end: removeEnd\n              });\n            }\n          } else if (end < currentTime) {\n            doRemove = true;\n\n            this._pendingRemoveRanges[type].push({\n              start: start,\n              end: end\n            });\n          }\n        }\n\n        if (doRemove && !sb.updating) {\n          this._doRemoveRanges();\n        }\n      }\n    }\n  }\n\n  _updateMediaSourceDuration() {\n    let sb = this._sourceBuffers;\n\n    if (this._mediaElement.readyState === 0 || this._mediaSource.readyState !== 'open') {\n      return;\n    }\n\n    if (sb.video && sb.video.updating || sb.audio && sb.audio.updating) {\n      return;\n    }\n\n    let current = this._mediaSource.duration;\n    let target = this._pendingMediaDuration;\n\n    if (target > 0 && (isNaN(current) || target > current)) {\n      Log.v(this.TAG, \"Update MediaSource duration from \".concat(current, \" to \").concat(target));\n      this._mediaSource.duration = target;\n    }\n\n    this._requireSetMediaDuration = false;\n    this._pendingMediaDuration = 0;\n  }\n\n  _doRemoveRanges() {\n    for (let type in this._pendingRemoveRanges) {\n      if (!this._sourceBuffers[type] || this._sourceBuffers[type].updating) {\n        continue;\n      }\n\n      let sb = this._sourceBuffers[type];\n      let ranges = this._pendingRemoveRanges[type];\n\n      while (ranges.length && !sb.updating) {\n        let range = ranges.shift();\n        sb.remove(range.start, range.end);\n      }\n    }\n  }\n\n  _doAppendSegments() {\n    let pendingSegments = this._pendingSegments;\n\n    for (let type in pendingSegments) {\n      if (!this._sourceBuffers[type] || this._sourceBuffers[type].updating) {\n        continue;\n      }\n\n      if (pendingSegments[type].length > 0) {\n        let segment = pendingSegments[type].shift();\n\n        if (segment.timestampOffset) {\n          // For MPEG audio stream in MSE, if unbuffered-seeking occurred\n          // We need explicitly set timestampOffset to the desired point in timeline for mpeg SourceBuffer.\n          let currentOffset = this._sourceBuffers[type].timestampOffset;\n          let targetOffset = segment.timestampOffset / 1000; // in seconds\n\n          let delta = Math.abs(currentOffset - targetOffset);\n\n          if (delta > 0.1) {\n            // If time delta > 100ms\n            Log.v(this.TAG, \"Update MPEG audio timestampOffset from \".concat(currentOffset, \" to \").concat(targetOffset));\n            this._sourceBuffers[type].timestampOffset = targetOffset;\n          }\n\n          delete segment.timestampOffset;\n        }\n\n        if (!segment.data || segment.data.byteLength === 0) {\n          // Ignore empty buffer\n          continue;\n        }\n\n        try {\n          this._sourceBuffers[type].appendBuffer(segment.data);\n\n          this._isBufferFull = false;\n\n          if (type === 'video' && segment.hasOwnProperty('info')) {\n            this._idrList.appendArray(segment.info.syncPoints);\n          }\n        } catch (error) {\n          this._pendingSegments[type].unshift(segment);\n\n          if (error.code === 22) {\n            // QuotaExceededError\n\n            /* Notice that FireFox may not throw QuotaExceededError if SourceBuffer is full\n             * Currently we can only do lazy-load to avoid SourceBuffer become scattered.\n             * SourceBuffer eviction policy may be changed in future version of FireFox.\n             *\n             * Related issues:\n             * https://bugzilla.mozilla.org/show_bug.cgi?id=1279885\n             * https://bugzilla.mozilla.org/show_bug.cgi?id=1280023\n             */\n            // report buffer full, abort network IO\n            if (!this._isBufferFull) {\n              this._emitter.emit(MSEEvents.BUFFER_FULL);\n            }\n\n            this._isBufferFull = true;\n          } else {\n            Log.e(this.TAG, error.message);\n\n            this._emitter.emit(MSEEvents.ERROR, {\n              code: error.code,\n              msg: error.message\n            });\n          }\n        }\n      }\n    }\n  }\n\n  _onSourceOpen() {\n    Log.v(this.TAG, 'MediaSource onSourceOpen');\n\n    this._mediaSource.removeEventListener('sourceopen', this.e.onSourceOpen); // deferred sourcebuffer creation / initialization\n\n\n    if (this._pendingSourceBufferInit.length > 0) {\n      let pendings = this._pendingSourceBufferInit;\n\n      while (pendings.length) {\n        let segment = pendings.shift();\n        this.appendInitSegment(segment, true);\n      }\n    } // there may be some pending media segments, append them\n\n\n    if (this._hasPendingSegments()) {\n      this._doAppendSegments();\n    }\n\n    this._emitter.emit(MSEEvents.SOURCE_OPEN);\n  }\n\n  _onSourceEnded() {\n    // fired on endOfStream\n    Log.v(this.TAG, 'MediaSource onSourceEnded');\n  }\n\n  _onSourceClose() {\n    // fired on detaching from media element\n    Log.v(this.TAG, 'MediaSource onSourceClose');\n\n    if (this._mediaSource && this.e != null) {\n      this._mediaSource.removeEventListener('sourceopen', this.e.onSourceOpen);\n\n      this._mediaSource.removeEventListener('sourceended', this.e.onSourceEnded);\n\n      this._mediaSource.removeEventListener('sourceclose', this.e.onSourceClose);\n    }\n  }\n\n  _hasPendingSegments() {\n    let ps = this._pendingSegments;\n    return ps.video.length > 0 || ps.audio.length > 0;\n  }\n\n  _hasPendingRemoveRanges() {\n    let prr = this._pendingRemoveRanges;\n    return prr.video.length > 0 || prr.audio.length > 0;\n  }\n\n  _onSourceBufferUpdateEnd() {\n    if (this._requireSetMediaDuration) {\n      this._updateMediaSourceDuration();\n    } else if (this._hasPendingRemoveRanges()) {\n      this._doRemoveRanges();\n    } else if (this._hasPendingSegments()) {\n      this._doAppendSegments();\n    } else if (this._hasPendingEos) {\n      this.endOfStream();\n    }\n\n    this._emitter.emit(MSEEvents.UPDATE_END);\n  }\n\n  _onSourceBufferError(e) {\n    Log.e(this.TAG, \"SourceBuffer Error: \".concat(e)); // this error might not always be fatal, just ignore it\n  }\n\n}\n\nexport default MSEController;","map":null,"metadata":{},"sourceType":"module"}