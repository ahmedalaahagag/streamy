{"ast":null,"code":"/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * This file is derived from dailymotion's hls.js library (hls.js/src/remux/mp4-generator.js)\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n//  MP4 boxes generator for ISO BMFF (ISO Base Media File Format, defined in ISO/IEC 14496-12)\nclass MP4 {\n  static init() {\n    MP4.types = {\n      avc1: [],\n      avcC: [],\n      btrt: [],\n      dinf: [],\n      dref: [],\n      esds: [],\n      ftyp: [],\n      hdlr: [],\n      mdat: [],\n      mdhd: [],\n      mdia: [],\n      mfhd: [],\n      minf: [],\n      moof: [],\n      moov: [],\n      mp4a: [],\n      mvex: [],\n      mvhd: [],\n      sdtp: [],\n      stbl: [],\n      stco: [],\n      stsc: [],\n      stsd: [],\n      stsz: [],\n      stts: [],\n      tfdt: [],\n      tfhd: [],\n      traf: [],\n      trak: [],\n      trun: [],\n      trex: [],\n      tkhd: [],\n      vmhd: [],\n      smhd: [],\n      '.mp3': []\n    };\n\n    for (let name in MP4.types) {\n      if (MP4.types.hasOwnProperty(name)) {\n        MP4.types[name] = [name.charCodeAt(0), name.charCodeAt(1), name.charCodeAt(2), name.charCodeAt(3)];\n      }\n    }\n\n    let constants = MP4.constants = {};\n    constants.FTYP = new Uint8Array([0x69, 0x73, 0x6F, 0x6D, // major_brand: isom\n    0x0, 0x0, 0x0, 0x1, // minor_version: 0x01\n    0x69, 0x73, 0x6F, 0x6D, // isom\n    0x61, 0x76, 0x63, 0x31 // avc1\n    ]);\n    constants.STSD_PREFIX = new Uint8Array([0x00, 0x00, 0x00, 0x00, // version(0) + flags\n    0x00, 0x00, 0x00, 0x01 // entry_count\n    ]);\n    constants.STTS = new Uint8Array([0x00, 0x00, 0x00, 0x00, // version(0) + flags\n    0x00, 0x00, 0x00, 0x00 // entry_count\n    ]);\n    constants.STSC = constants.STCO = constants.STTS;\n    constants.STSZ = new Uint8Array([0x00, 0x00, 0x00, 0x00, // version(0) + flags\n    0x00, 0x00, 0x00, 0x00, // sample_size\n    0x00, 0x00, 0x00, 0x00 // sample_count\n    ]);\n    constants.HDLR_VIDEO = new Uint8Array([0x00, 0x00, 0x00, 0x00, // version(0) + flags\n    0x00, 0x00, 0x00, 0x00, // pre_defined\n    0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'\n    0x00, 0x00, 0x00, 0x00, // reserved: 3 * 4 bytes\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x56, 0x69, 0x64, 0x65, 0x6F, 0x48, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x72, 0x00 // name: VideoHandler\n    ]);\n    constants.HDLR_AUDIO = new Uint8Array([0x00, 0x00, 0x00, 0x00, // version(0) + flags\n    0x00, 0x00, 0x00, 0x00, // pre_defined\n    0x73, 0x6F, 0x75, 0x6E, // handler_type: 'soun'\n    0x00, 0x00, 0x00, 0x00, // reserved: 3 * 4 bytes\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x53, 0x6F, 0x75, 0x6E, 0x64, 0x48, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x72, 0x00 // name: SoundHandler\n    ]);\n    constants.DREF = new Uint8Array([0x00, 0x00, 0x00, 0x00, // version(0) + flags\n    0x00, 0x00, 0x00, 0x01, // entry_count\n    0x00, 0x00, 0x00, 0x0C, // entry_size\n    0x75, 0x72, 0x6C, 0x20, // type 'url '\n    0x00, 0x00, 0x00, 0x01 // version(0) + flags\n    ]); // Sound media header\n\n    constants.SMHD = new Uint8Array([0x00, 0x00, 0x00, 0x00, // version(0) + flags\n    0x00, 0x00, 0x00, 0x00 // balance(2) + reserved(2)\n    ]); // video media header\n\n    constants.VMHD = new Uint8Array([0x00, 0x00, 0x00, 0x01, // version(0) + flags\n    0x00, 0x00, // graphicsmode: 2 bytes\n    0x00, 0x00, 0x00, 0x00, // opcolor: 3 * 2 bytes\n    0x00, 0x00]);\n  } // Generate a box\n\n\n  static box(type) {\n    let size = 8;\n    let result = null;\n    let datas = Array.prototype.slice.call(arguments, 1);\n    let arrayCount = datas.length;\n\n    for (let i = 0; i < arrayCount; i++) {\n      size += datas[i].byteLength;\n    }\n\n    result = new Uint8Array(size);\n    result[0] = size >>> 24 & 0xFF; // size\n\n    result[1] = size >>> 16 & 0xFF;\n    result[2] = size >>> 8 & 0xFF;\n    result[3] = size & 0xFF;\n    result.set(type, 4); // type\n\n    let offset = 8;\n\n    for (let i = 0; i < arrayCount; i++) {\n      // data body\n      result.set(datas[i], offset);\n      offset += datas[i].byteLength;\n    }\n\n    return result;\n  } // emit ftyp & moov\n\n\n  static generateInitSegment(meta) {\n    let ftyp = MP4.box(MP4.types.ftyp, MP4.constants.FTYP);\n    let moov = MP4.moov(meta);\n    let result = new Uint8Array(ftyp.byteLength + moov.byteLength);\n    result.set(ftyp, 0);\n    result.set(moov, ftyp.byteLength);\n    return result;\n  } // Movie metadata box\n\n\n  static moov(meta) {\n    let mvhd = MP4.mvhd(meta.timescale, meta.duration);\n    let trak = MP4.trak(meta);\n    let mvex = MP4.mvex(meta);\n    return MP4.box(MP4.types.moov, mvhd, trak, mvex);\n  } // Movie header box\n\n\n  static mvhd(timescale, duration) {\n    return MP4.box(MP4.types.mvhd, new Uint8Array([0x00, 0x00, 0x00, 0x00, // version(0) + flags\n    0x00, 0x00, 0x00, 0x00, // creation_time\n    0x00, 0x00, 0x00, 0x00, // modification_time\n    timescale >>> 24 & 0xFF, // timescale: 4 bytes\n    timescale >>> 16 & 0xFF, timescale >>> 8 & 0xFF, timescale & 0xFF, duration >>> 24 & 0xFF, // duration: 4 bytes\n    duration >>> 16 & 0xFF, duration >>> 8 & 0xFF, duration & 0xFF, 0x00, 0x01, 0x00, 0x00, // Preferred rate: 1.0\n    0x01, 0x00, 0x00, 0x00, // PreferredVolume(1.0, 2bytes) + reserved(2bytes)\n    0x00, 0x00, 0x00, 0x00, // reserved: 4 + 4 bytes\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, // ----begin composition matrix----\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // ----end composition matrix----\n    0x00, 0x00, 0x00, 0x00, // ----begin pre_defined 6 * 4 bytes----\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ----end pre_defined 6 * 4 bytes----\n    0xFF, 0xFF, 0xFF, 0xFF // next_track_ID\n    ]));\n  } // Track box\n\n\n  static trak(meta) {\n    return MP4.box(MP4.types.trak, MP4.tkhd(meta), MP4.mdia(meta));\n  } // Track header box\n\n\n  static tkhd(meta) {\n    let trackId = meta.id,\n        duration = meta.duration;\n    let width = meta.presentWidth,\n        height = meta.presentHeight;\n    return MP4.box(MP4.types.tkhd, new Uint8Array([0x00, 0x00, 0x00, 0x07, // version(0) + flags\n    0x00, 0x00, 0x00, 0x00, // creation_time\n    0x00, 0x00, 0x00, 0x00, // modification_time\n    trackId >>> 24 & 0xFF, // track_ID: 4 bytes\n    trackId >>> 16 & 0xFF, trackId >>> 8 & 0xFF, trackId & 0xFF, 0x00, 0x00, 0x00, 0x00, // reserved: 4 bytes\n    duration >>> 24 & 0xFF, // duration: 4 bytes\n    duration >>> 16 & 0xFF, duration >>> 8 & 0xFF, duration & 0xFF, 0x00, 0x00, 0x00, 0x00, // reserved: 2 * 4 bytes\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // layer(2bytes) + alternate_group(2bytes)\n    0x00, 0x00, 0x00, 0x00, // volume(2bytes) + reserved(2bytes)\n    0x00, 0x01, 0x00, 0x00, // ----begin composition matrix----\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // ----end composition matrix----\n    width >>> 8 & 0xFF, // width and height\n    width & 0xFF, 0x00, 0x00, height >>> 8 & 0xFF, height & 0xFF, 0x00, 0x00]));\n  } // Media Box\n\n\n  static mdia(meta) {\n    return MP4.box(MP4.types.mdia, MP4.mdhd(meta), MP4.hdlr(meta), MP4.minf(meta));\n  } // Media header box\n\n\n  static mdhd(meta) {\n    let timescale = meta.timescale;\n    let duration = meta.duration;\n    return MP4.box(MP4.types.mdhd, new Uint8Array([0x00, 0x00, 0x00, 0x00, // version(0) + flags\n    0x00, 0x00, 0x00, 0x00, // creation_time\n    0x00, 0x00, 0x00, 0x00, // modification_time\n    timescale >>> 24 & 0xFF, // timescale: 4 bytes\n    timescale >>> 16 & 0xFF, timescale >>> 8 & 0xFF, timescale & 0xFF, duration >>> 24 & 0xFF, // duration: 4 bytes\n    duration >>> 16 & 0xFF, duration >>> 8 & 0xFF, duration & 0xFF, 0x55, 0xC4, // language: und (undetermined)\n    0x00, 0x00 // pre_defined = 0\n    ]));\n  } // Media handler reference box\n\n\n  static hdlr(meta) {\n    let data = null;\n\n    if (meta.type === 'audio') {\n      data = MP4.constants.HDLR_AUDIO;\n    } else {\n      data = MP4.constants.HDLR_VIDEO;\n    }\n\n    return MP4.box(MP4.types.hdlr, data);\n  } // Media infomation box\n\n\n  static minf(meta) {\n    let xmhd = null;\n\n    if (meta.type === 'audio') {\n      xmhd = MP4.box(MP4.types.smhd, MP4.constants.SMHD);\n    } else {\n      xmhd = MP4.box(MP4.types.vmhd, MP4.constants.VMHD);\n    }\n\n    return MP4.box(MP4.types.minf, xmhd, MP4.dinf(), MP4.stbl(meta));\n  } // Data infomation box\n\n\n  static dinf() {\n    let result = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, MP4.constants.DREF));\n    return result;\n  } // Sample table box\n\n\n  static stbl(meta) {\n    let result = MP4.box(MP4.types.stbl, // type: stbl\n    MP4.stsd(meta), // Sample Description Table\n    MP4.box(MP4.types.stts, MP4.constants.STTS), // Time-To-Sample\n    MP4.box(MP4.types.stsc, MP4.constants.STSC), // Sample-To-Chunk\n    MP4.box(MP4.types.stsz, MP4.constants.STSZ), // Sample size\n    MP4.box(MP4.types.stco, MP4.constants.STCO) // Chunk offset\n    );\n    return result;\n  } // Sample description box\n\n\n  static stsd(meta) {\n    if (meta.type === 'audio') {\n      if (meta.codec === 'mp3') {\n        return MP4.box(MP4.types.stsd, MP4.constants.STSD_PREFIX, MP4.mp3(meta));\n      } // else: aac -> mp4a\n\n\n      return MP4.box(MP4.types.stsd, MP4.constants.STSD_PREFIX, MP4.mp4a(meta));\n    } else {\n      return MP4.box(MP4.types.stsd, MP4.constants.STSD_PREFIX, MP4.avc1(meta));\n    }\n  }\n\n  static mp3(meta) {\n    let channelCount = meta.channelCount;\n    let sampleRate = meta.audioSampleRate;\n    let data = new Uint8Array([0x00, 0x00, 0x00, 0x00, // reserved(4)\n    0x00, 0x00, 0x00, 0x01, // reserved(2) + data_reference_index(2)\n    0x00, 0x00, 0x00, 0x00, // reserved: 2 * 4 bytes\n    0x00, 0x00, 0x00, 0x00, 0x00, channelCount, // channelCount(2)\n    0x00, 0x10, // sampleSize(2)\n    0x00, 0x00, 0x00, 0x00, // reserved(4)\n    sampleRate >>> 8 & 0xFF, // Audio sample rate\n    sampleRate & 0xFF, 0x00, 0x00]);\n    return MP4.box(MP4.types['.mp3'], data);\n  }\n\n  static mp4a(meta) {\n    let channelCount = meta.channelCount;\n    let sampleRate = meta.audioSampleRate;\n    let data = new Uint8Array([0x00, 0x00, 0x00, 0x00, // reserved(4)\n    0x00, 0x00, 0x00, 0x01, // reserved(2) + data_reference_index(2)\n    0x00, 0x00, 0x00, 0x00, // reserved: 2 * 4 bytes\n    0x00, 0x00, 0x00, 0x00, 0x00, channelCount, // channelCount(2)\n    0x00, 0x10, // sampleSize(2)\n    0x00, 0x00, 0x00, 0x00, // reserved(4)\n    sampleRate >>> 8 & 0xFF, // Audio sample rate\n    sampleRate & 0xFF, 0x00, 0x00]);\n    return MP4.box(MP4.types.mp4a, data, MP4.esds(meta));\n  }\n\n  static esds(meta) {\n    let config = meta.config || [];\n    let configSize = config.length;\n    let data = new Uint8Array([0x00, 0x00, 0x00, 0x00, // version 0 + flags\n    0x03, // descriptor_type\n    0x17 + configSize, // length3\n    0x00, 0x01, // es_id\n    0x00, // stream_priority\n    0x04, // descriptor_type\n    0x0F + configSize, // length\n    0x40, // codec: mpeg4_audio\n    0x15, // stream_type: Audio\n    0x00, 0x00, 0x00, // buffer_size\n    0x00, 0x00, 0x00, 0x00, // maxBitrate\n    0x00, 0x00, 0x00, 0x00, // avgBitrate\n    0x05 // descriptor_type\n    ].concat([configSize]).concat(config).concat([0x06, 0x01, 0x02 // GASpecificConfig\n    ]));\n    return MP4.box(MP4.types.esds, data);\n  }\n\n  static avc1(meta) {\n    let avcc = meta.avcc;\n    let width = meta.codecWidth,\n        height = meta.codecHeight;\n    let data = new Uint8Array([0x00, 0x00, 0x00, 0x00, // reserved(4)\n    0x00, 0x00, 0x00, 0x01, // reserved(2) + data_reference_index(2)\n    0x00, 0x00, 0x00, 0x00, // pre_defined(2) + reserved(2)\n    0x00, 0x00, 0x00, 0x00, // pre_defined: 3 * 4 bytes\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, width >>> 8 & 0xFF, // width: 2 bytes\n    width & 0xFF, height >>> 8 & 0xFF, // height: 2 bytes\n    height & 0xFF, 0x00, 0x48, 0x00, 0x00, // horizresolution: 4 bytes\n    0x00, 0x48, 0x00, 0x00, // vertresolution: 4 bytes\n    0x00, 0x00, 0x00, 0x00, // reserved: 4 bytes\n    0x00, 0x01, // frame_count\n    0x0A, // strlen\n    0x78, 0x71, 0x71, 0x2F, // compressorname: 32 bytes\n    0x66, 0x6C, 0x76, 0x2E, 0x6A, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, // depth\n    0xFF, 0xFF // pre_defined = -1\n    ]);\n    return MP4.box(MP4.types.avc1, data, MP4.box(MP4.types.avcC, avcc));\n  } // Movie Extends box\n\n\n  static mvex(meta) {\n    return MP4.box(MP4.types.mvex, MP4.trex(meta));\n  } // Track Extends box\n\n\n  static trex(meta) {\n    let trackId = meta.id;\n    let data = new Uint8Array([0x00, 0x00, 0x00, 0x00, // version(0) + flags\n    trackId >>> 24 & 0xFF, // track_ID\n    trackId >>> 16 & 0xFF, trackId >>> 8 & 0xFF, trackId & 0xFF, 0x00, 0x00, 0x00, 0x01, // default_sample_description_index\n    0x00, 0x00, 0x00, 0x00, // default_sample_duration\n    0x00, 0x00, 0x00, 0x00, // default_sample_size\n    0x00, 0x01, 0x00, 0x01 // default_sample_flags\n    ]);\n    return MP4.box(MP4.types.trex, data);\n  } // Movie fragment box\n\n\n  static moof(track, baseMediaDecodeTime) {\n    return MP4.box(MP4.types.moof, MP4.mfhd(track.sequenceNumber), MP4.traf(track, baseMediaDecodeTime));\n  }\n\n  static mfhd(sequenceNumber) {\n    let data = new Uint8Array([0x00, 0x00, 0x00, 0x00, sequenceNumber >>> 24 & 0xFF, // sequence_number: int32\n    sequenceNumber >>> 16 & 0xFF, sequenceNumber >>> 8 & 0xFF, sequenceNumber & 0xFF]);\n    return MP4.box(MP4.types.mfhd, data);\n  } // Track fragment box\n\n\n  static traf(track, baseMediaDecodeTime) {\n    let trackId = track.id; // Track fragment header box\n\n    let tfhd = MP4.box(MP4.types.tfhd, new Uint8Array([0x00, 0x00, 0x00, 0x00, // version(0) & flags\n    trackId >>> 24 & 0xFF, // track_ID\n    trackId >>> 16 & 0xFF, trackId >>> 8 & 0xFF, trackId & 0xFF])); // Track Fragment Decode Time\n\n    let tfdt = MP4.box(MP4.types.tfdt, new Uint8Array([0x00, 0x00, 0x00, 0x00, // version(0) & flags\n    baseMediaDecodeTime >>> 24 & 0xFF, // baseMediaDecodeTime: int32\n    baseMediaDecodeTime >>> 16 & 0xFF, baseMediaDecodeTime >>> 8 & 0xFF, baseMediaDecodeTime & 0xFF]));\n    let sdtp = MP4.sdtp(track);\n    let trun = MP4.trun(track, sdtp.byteLength + 16 + 16 + 8 + 16 + 8 + 8);\n    return MP4.box(MP4.types.traf, tfhd, tfdt, trun, sdtp);\n  } // Sample Dependency Type box\n\n\n  static sdtp(track) {\n    let samples = track.samples || [];\n    let sampleCount = samples.length;\n    let data = new Uint8Array(4 + sampleCount); // 0~4 bytes: version(0) & flags\n\n    for (let i = 0; i < sampleCount; i++) {\n      let flags = samples[i].flags;\n      data[i + 4] = flags.isLeading << 6 | // is_leading: 2 (bit)\n      flags.dependsOn << 4 // sample_depends_on\n      | flags.isDependedOn << 2 // sample_is_depended_on\n      | flags.hasRedundancy; // sample_has_redundancy\n    }\n\n    return MP4.box(MP4.types.sdtp, data);\n  } // Track fragment run box\n\n\n  static trun(track, offset) {\n    let samples = track.samples || [];\n    let sampleCount = samples.length;\n    let dataSize = 12 + 16 * sampleCount;\n    let data = new Uint8Array(dataSize);\n    offset += 8 + dataSize;\n    data.set([0x00, 0x00, 0x0F, 0x01, // version(0) & flags\n    sampleCount >>> 24 & 0xFF, // sample_count\n    sampleCount >>> 16 & 0xFF, sampleCount >>> 8 & 0xFF, sampleCount & 0xFF, offset >>> 24 & 0xFF, // data_offset\n    offset >>> 16 & 0xFF, offset >>> 8 & 0xFF, offset & 0xFF], 0);\n\n    for (let i = 0; i < sampleCount; i++) {\n      let duration = samples[i].duration;\n      let size = samples[i].size;\n      let flags = samples[i].flags;\n      let cts = samples[i].cts;\n      data.set([duration >>> 24 & 0xFF, // sample_duration\n      duration >>> 16 & 0xFF, duration >>> 8 & 0xFF, duration & 0xFF, size >>> 24 & 0xFF, // sample_size\n      size >>> 16 & 0xFF, size >>> 8 & 0xFF, size & 0xFF, flags.isLeading << 2 | flags.dependsOn, // sample_flags\n      flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.isNonSync, 0x00, 0x00, // sample_degradation_priority\n      cts >>> 24 & 0xFF, // sample_composition_time_offset\n      cts >>> 16 & 0xFF, cts >>> 8 & 0xFF, cts & 0xFF], 12 + 16 * i);\n    }\n\n    return MP4.box(MP4.types.trun, data);\n  }\n\n  static mdat(data) {\n    return MP4.box(MP4.types.mdat, data);\n  }\n\n}\n\nMP4.init();\nexport default MP4;","map":null,"metadata":{},"sourceType":"module"}