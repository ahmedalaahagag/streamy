{"ast":null,"code":"/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport Log from '../utils/logger.js';\nimport decodeUTF8 from '../utils/utf8-conv.js';\nimport { IllegalStateException } from '../utils/exception.js';\n\nlet le = function () {\n  let buf = new ArrayBuffer(2);\n  new DataView(buf).setInt16(0, 256, true); // little-endian write\n\n  return new Int16Array(buf)[0] === 256; // platform-spec read, if equal then LE\n}();\n\nclass AMF {\n  static parseScriptData(arrayBuffer, dataOffset, dataSize) {\n    let data = {};\n\n    try {\n      let name = AMF.parseValue(arrayBuffer, dataOffset, dataSize);\n      let value = AMF.parseValue(arrayBuffer, dataOffset + name.size, dataSize - name.size);\n      data[name.data] = value.data;\n    } catch (e) {\n      Log.e('AMF', e.toString());\n    }\n\n    return data;\n  }\n\n  static parseObject(arrayBuffer, dataOffset, dataSize) {\n    if (dataSize < 3) {\n      throw new IllegalStateException('Data not enough when parse ScriptDataObject');\n    }\n\n    let name = AMF.parseString(arrayBuffer, dataOffset, dataSize);\n    let value = AMF.parseValue(arrayBuffer, dataOffset + name.size, dataSize - name.size);\n    let isObjectEnd = value.objectEnd;\n    return {\n      data: {\n        name: name.data,\n        value: value.data\n      },\n      size: name.size + value.size,\n      objectEnd: isObjectEnd\n    };\n  }\n\n  static parseVariable(arrayBuffer, dataOffset, dataSize) {\n    return AMF.parseObject(arrayBuffer, dataOffset, dataSize);\n  }\n\n  static parseString(arrayBuffer, dataOffset, dataSize) {\n    if (dataSize < 2) {\n      throw new IllegalStateException('Data not enough when parse String');\n    }\n\n    let v = new DataView(arrayBuffer, dataOffset, dataSize);\n    let length = v.getUint16(0, !le);\n    let str;\n\n    if (length > 0) {\n      str = decodeUTF8(new Uint8Array(arrayBuffer, dataOffset + 2, length));\n    } else {\n      str = '';\n    }\n\n    return {\n      data: str,\n      size: 2 + length\n    };\n  }\n\n  static parseLongString(arrayBuffer, dataOffset, dataSize) {\n    if (dataSize < 4) {\n      throw new IllegalStateException('Data not enough when parse LongString');\n    }\n\n    let v = new DataView(arrayBuffer, dataOffset, dataSize);\n    let length = v.getUint32(0, !le);\n    let str;\n\n    if (length > 0) {\n      str = decodeUTF8(new Uint8Array(arrayBuffer, dataOffset + 4, length));\n    } else {\n      str = '';\n    }\n\n    return {\n      data: str,\n      size: 4 + length\n    };\n  }\n\n  static parseDate(arrayBuffer, dataOffset, dataSize) {\n    if (dataSize < 10) {\n      throw new IllegalStateException('Data size invalid when parse Date');\n    }\n\n    let v = new DataView(arrayBuffer, dataOffset, dataSize);\n    let timestamp = v.getFloat64(0, !le);\n    let localTimeOffset = v.getInt16(8, !le);\n    timestamp += localTimeOffset * 60 * 1000; // get UTC time\n\n    return {\n      data: new Date(timestamp),\n      size: 8 + 2\n    };\n  }\n\n  static parseValue(arrayBuffer, dataOffset, dataSize) {\n    if (dataSize < 1) {\n      throw new IllegalStateException('Data not enough when parse Value');\n    }\n\n    let v = new DataView(arrayBuffer, dataOffset, dataSize);\n    let offset = 1;\n    let type = v.getUint8(0);\n    let value;\n    let objectEnd = false;\n\n    try {\n      switch (type) {\n        case 0:\n          // Number(Double) type\n          value = v.getFloat64(1, !le);\n          offset += 8;\n          break;\n\n        case 1:\n          {\n            // Boolean type\n            let b = v.getUint8(1);\n            value = b ? true : false;\n            offset += 1;\n            break;\n          }\n\n        case 2:\n          {\n            // String type\n            let amfstr = AMF.parseString(arrayBuffer, dataOffset + 1, dataSize - 1);\n            value = amfstr.data;\n            offset += amfstr.size;\n            break;\n          }\n\n        case 3:\n          {\n            // Object(s) type\n            value = {};\n            let terminal = 0; // workaround for malformed Objects which has missing ScriptDataObjectEnd\n\n            if ((v.getUint32(dataSize - 4, !le) & 0x00FFFFFF) === 9) {\n              terminal = 3;\n            }\n\n            while (offset < dataSize - 4) {\n              // 4 === type(UI8) + ScriptDataObjectEnd(UI24)\n              let amfobj = AMF.parseObject(arrayBuffer, dataOffset + offset, dataSize - offset - terminal);\n              if (amfobj.objectEnd) break;\n              value[amfobj.data.name] = amfobj.data.value;\n              offset += amfobj.size;\n            }\n\n            if (offset <= dataSize - 3) {\n              let marker = v.getUint32(offset - 1, !le) & 0x00FFFFFF;\n\n              if (marker === 9) {\n                offset += 3;\n              }\n            }\n\n            break;\n          }\n\n        case 8:\n          {\n            // ECMA array type (Mixed array)\n            value = {};\n            offset += 4; // ECMAArrayLength(UI32)\n\n            let terminal = 0; // workaround for malformed MixedArrays which has missing ScriptDataObjectEnd\n\n            if ((v.getUint32(dataSize - 4, !le) & 0x00FFFFFF) === 9) {\n              terminal = 3;\n            }\n\n            while (offset < dataSize - 8) {\n              // 8 === type(UI8) + ECMAArrayLength(UI32) + ScriptDataVariableEnd(UI24)\n              let amfvar = AMF.parseVariable(arrayBuffer, dataOffset + offset, dataSize - offset - terminal);\n              if (amfvar.objectEnd) break;\n              value[amfvar.data.name] = amfvar.data.value;\n              offset += amfvar.size;\n            }\n\n            if (offset <= dataSize - 3) {\n              let marker = v.getUint32(offset - 1, !le) & 0x00FFFFFF;\n\n              if (marker === 9) {\n                offset += 3;\n              }\n            }\n\n            break;\n          }\n\n        case 9:\n          // ScriptDataObjectEnd\n          value = undefined;\n          offset = 1;\n          objectEnd = true;\n          break;\n\n        case 10:\n          {\n            // Strict array type\n            // ScriptDataValue[n]. NOTE: according to video_file_format_spec_v10_1.pdf\n            value = [];\n            let strictArrayLength = v.getUint32(1, !le);\n            offset += 4;\n\n            for (let i = 0; i < strictArrayLength; i++) {\n              let val = AMF.parseValue(arrayBuffer, dataOffset + offset, dataSize - offset);\n              value.push(val.data);\n              offset += val.size;\n            }\n\n            break;\n          }\n\n        case 11:\n          {\n            // Date type\n            let date = AMF.parseDate(arrayBuffer, dataOffset + 1, dataSize - 1);\n            value = date.data;\n            offset += date.size;\n            break;\n          }\n\n        case 12:\n          {\n            // Long string type\n            let amfLongStr = AMF.parseString(arrayBuffer, dataOffset + 1, dataSize - 1);\n            value = amfLongStr.data;\n            offset += amfLongStr.size;\n            break;\n          }\n\n        default:\n          // ignore and skip\n          offset = dataSize;\n          Log.w('AMF', 'Unsupported AMF value type ' + type);\n      }\n    } catch (e) {\n      Log.e('AMF', e.toString());\n    }\n\n    return {\n      data: value,\n      size: offset,\n      objectEnd: objectEnd\n    };\n  }\n\n}\n\nexport default AMF;","map":null,"metadata":{},"sourceType":"module"}