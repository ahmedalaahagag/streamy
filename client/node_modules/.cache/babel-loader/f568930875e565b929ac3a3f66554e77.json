{"ast":null,"code":"/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Utility class to calculate realtime network I/O speed\nclass SpeedSampler {\n  constructor() {\n    // milliseconds\n    this._firstCheckpoint = 0;\n    this._lastCheckpoint = 0;\n    this._intervalBytes = 0;\n    this._totalBytes = 0;\n    this._lastSecondBytes = 0; // compatibility detection\n\n    if (self.performance && self.performance.now) {\n      this._now = self.performance.now.bind(self.performance);\n    } else {\n      this._now = Date.now;\n    }\n  }\n\n  reset() {\n    this._firstCheckpoint = this._lastCheckpoint = 0;\n    this._totalBytes = this._intervalBytes = 0;\n    this._lastSecondBytes = 0;\n  }\n\n  addBytes(bytes) {\n    if (this._firstCheckpoint === 0) {\n      this._firstCheckpoint = this._now();\n      this._lastCheckpoint = this._firstCheckpoint;\n      this._intervalBytes += bytes;\n      this._totalBytes += bytes;\n    } else if (this._now() - this._lastCheckpoint < 1000) {\n      this._intervalBytes += bytes;\n      this._totalBytes += bytes;\n    } else {\n      // duration >= 1000\n      this._lastSecondBytes = this._intervalBytes;\n      this._intervalBytes = bytes;\n      this._totalBytes += bytes;\n      this._lastCheckpoint = this._now();\n    }\n  }\n\n  get currentKBps() {\n    this.addBytes(0);\n    let durationSeconds = (this._now() - this._lastCheckpoint) / 1000;\n    if (durationSeconds == 0) durationSeconds = 1;\n    return this._intervalBytes / durationSeconds / 1024;\n  }\n\n  get lastSecondKBps() {\n    this.addBytes(0);\n\n    if (this._lastSecondBytes !== 0) {\n      return this._lastSecondBytes / 1024;\n    } else {\n      // lastSecondBytes === 0\n      if (this._now() - this._lastCheckpoint >= 500) {\n        // if time interval since last checkpoint has exceeded 500ms\n        // the speed is nearly accurate\n        return this.currentKBps;\n      } else {\n        // We don't know\n        return 0;\n      }\n    }\n  }\n\n  get averageKBps() {\n    let durationSeconds = (this._now() - this._firstCheckpoint) / 1000;\n    return this._totalBytes / durationSeconds / 1024;\n  }\n\n}\n\nexport default SpeedSampler;","map":null,"metadata":{},"sourceType":"module"}