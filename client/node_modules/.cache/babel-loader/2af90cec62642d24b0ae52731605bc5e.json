{"ast":null,"code":"/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Represents an media sample (audio / video)\nexport class SampleInfo {\n  constructor(dts, pts, duration, originalDts, isSync) {\n    this.dts = dts;\n    this.pts = pts;\n    this.duration = duration;\n    this.originalDts = originalDts;\n    this.isSyncPoint = isSync;\n    this.fileposition = null;\n  }\n\n} // Media Segment concept is defined in Media Source Extensions spec.\n// Particularly in ISO BMFF format, an Media Segment contains a moof box followed by a mdat box.\n\nexport class MediaSegmentInfo {\n  constructor() {\n    this.beginDts = 0;\n    this.endDts = 0;\n    this.beginPts = 0;\n    this.endPts = 0;\n    this.originalBeginDts = 0;\n    this.originalEndDts = 0;\n    this.syncPoints = []; // SampleInfo[n], for video IDR frames only\n\n    this.firstSample = null; // SampleInfo\n\n    this.lastSample = null; // SampleInfo\n  }\n\n  appendSyncPoint(sampleInfo) {\n    // also called Random Access Point\n    sampleInfo.isSyncPoint = true;\n    this.syncPoints.push(sampleInfo);\n  }\n\n} // Ordered list for recording video IDR frames, sorted by originalDts\n\nexport class IDRSampleList {\n  constructor() {\n    this._list = [];\n  }\n\n  clear() {\n    this._list = [];\n  }\n\n  appendArray(syncPoints) {\n    let list = this._list;\n\n    if (syncPoints.length === 0) {\n      return;\n    }\n\n    if (list.length > 0 && syncPoints[0].originalDts < list[list.length - 1].originalDts) {\n      this.clear();\n    }\n\n    Array.prototype.push.apply(list, syncPoints);\n  }\n\n  getLastSyncPointBeforeDts(dts) {\n    if (this._list.length == 0) {\n      return null;\n    }\n\n    let list = this._list;\n    let idx = 0;\n    let last = list.length - 1;\n    let mid = 0;\n    let lbound = 0;\n    let ubound = last;\n\n    if (dts < list[0].dts) {\n      idx = 0;\n      lbound = ubound + 1;\n    }\n\n    while (lbound <= ubound) {\n      mid = lbound + Math.floor((ubound - lbound) / 2);\n\n      if (mid === last || dts >= list[mid].dts && dts < list[mid + 1].dts) {\n        idx = mid;\n        break;\n      } else if (list[mid].dts < dts) {\n        lbound = mid + 1;\n      } else {\n        ubound = mid - 1;\n      }\n    }\n\n    return this._list[idx];\n  }\n\n} // Data structure for recording information of media segments in single track.\n\nexport class MediaSegmentInfoList {\n  constructor(type) {\n    this._type = type;\n    this._list = [];\n    this._lastAppendLocation = -1; // cached last insert location\n  }\n\n  get type() {\n    return this._type;\n  }\n\n  get length() {\n    return this._list.length;\n  }\n\n  isEmpty() {\n    return this._list.length === 0;\n  }\n\n  clear() {\n    this._list = [];\n    this._lastAppendLocation = -1;\n  }\n\n  _searchNearestSegmentBefore(originalBeginDts) {\n    let list = this._list;\n\n    if (list.length === 0) {\n      return -2;\n    }\n\n    let last = list.length - 1;\n    let mid = 0;\n    let lbound = 0;\n    let ubound = last;\n    let idx = 0;\n\n    if (originalBeginDts < list[0].originalBeginDts) {\n      idx = -1;\n      return idx;\n    }\n\n    while (lbound <= ubound) {\n      mid = lbound + Math.floor((ubound - lbound) / 2);\n\n      if (mid === last || originalBeginDts > list[mid].lastSample.originalDts && originalBeginDts < list[mid + 1].originalBeginDts) {\n        idx = mid;\n        break;\n      } else if (list[mid].originalBeginDts < originalBeginDts) {\n        lbound = mid + 1;\n      } else {\n        ubound = mid - 1;\n      }\n    }\n\n    return idx;\n  }\n\n  _searchNearestSegmentAfter(originalBeginDts) {\n    return this._searchNearestSegmentBefore(originalBeginDts) + 1;\n  }\n\n  append(mediaSegmentInfo) {\n    let list = this._list;\n    let msi = mediaSegmentInfo;\n    let lastAppendIdx = this._lastAppendLocation;\n    let insertIdx = 0;\n\n    if (lastAppendIdx !== -1 && lastAppendIdx < list.length && msi.originalBeginDts >= list[lastAppendIdx].lastSample.originalDts && (lastAppendIdx === list.length - 1 || lastAppendIdx < list.length - 1 && msi.originalBeginDts < list[lastAppendIdx + 1].originalBeginDts)) {\n      insertIdx = lastAppendIdx + 1; // use cached location idx\n    } else {\n      if (list.length > 0) {\n        insertIdx = this._searchNearestSegmentBefore(msi.originalBeginDts) + 1;\n      }\n    }\n\n    this._lastAppendLocation = insertIdx;\n\n    this._list.splice(insertIdx, 0, msi);\n  }\n\n  getLastSegmentBefore(originalBeginDts) {\n    let idx = this._searchNearestSegmentBefore(originalBeginDts);\n\n    if (idx >= 0) {\n      return this._list[idx];\n    } else {\n      // -1\n      return null;\n    }\n  }\n\n  getLastSampleBefore(originalBeginDts) {\n    let segment = this.getLastSegmentBefore(originalBeginDts);\n\n    if (segment != null) {\n      return segment.lastSample;\n    } else {\n      return null;\n    }\n  }\n\n  getLastSyncPointBefore(originalBeginDts) {\n    let segmentIdx = this._searchNearestSegmentBefore(originalBeginDts);\n\n    let syncPoints = this._list[segmentIdx].syncPoints;\n\n    while (syncPoints.length === 0 && segmentIdx > 0) {\n      segmentIdx--;\n      syncPoints = this._list[segmentIdx].syncPoints;\n    }\n\n    if (syncPoints.length > 0) {\n      return syncPoints[syncPoints.length - 1];\n    } else {\n      return null;\n    }\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}