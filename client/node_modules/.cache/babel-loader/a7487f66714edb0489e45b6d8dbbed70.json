{"ast":null,"code":"/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport Log from '../utils/logger.js';\nimport SpeedSampler from './speed-sampler.js';\nimport { BaseLoader, LoaderStatus, LoaderErrors } from './loader.js';\nimport { RuntimeException } from '../utils/exception.js'; // Universal IO Loader, implemented by adding Range header in xhr's request header\n\nclass RangeLoader extends BaseLoader {\n  static isSupported() {\n    try {\n      let xhr = new XMLHttpRequest();\n      xhr.open('GET', 'https://example.com', true);\n      xhr.responseType = 'arraybuffer';\n      return xhr.responseType === 'arraybuffer';\n    } catch (e) {\n      Log.w('RangeLoader', e.message);\n      return false;\n    }\n  }\n\n  constructor(seekHandler, config) {\n    super('xhr-range-loader');\n    this.TAG = 'RangeLoader';\n    this._seekHandler = seekHandler;\n    this._config = config;\n    this._needStash = false;\n    this._chunkSizeKBList = [128, 256, 384, 512, 768, 1024, 1536, 2048, 3072, 4096, 5120, 6144, 7168, 8192];\n    this._currentChunkSizeKB = 384;\n    this._currentSpeedNormalized = 0;\n    this._zeroSpeedChunkCount = 0;\n    this._xhr = null;\n    this._speedSampler = new SpeedSampler();\n    this._requestAbort = false;\n    this._waitForTotalLength = false;\n    this._totalLengthReceived = false;\n    this._currentRequestURL = null;\n    this._currentRedirectedURL = null;\n    this._currentRequestRange = null;\n    this._totalLength = null; // size of the entire file\n\n    this._contentLength = null; // Content-Length of entire request range\n\n    this._receivedLength = 0; // total received bytes\n\n    this._lastTimeLoaded = 0; // received bytes of current request sub-range\n  }\n\n  destroy() {\n    if (this.isWorking()) {\n      this.abort();\n    }\n\n    if (this._xhr) {\n      this._xhr.onreadystatechange = null;\n      this._xhr.onprogress = null;\n      this._xhr.onload = null;\n      this._xhr.onerror = null;\n      this._xhr = null;\n    }\n\n    super.destroy();\n  }\n\n  get currentSpeed() {\n    return this._speedSampler.lastSecondKBps;\n  }\n\n  open(dataSource, range) {\n    this._dataSource = dataSource;\n    this._range = range;\n    this._status = LoaderStatus.kConnecting;\n    let useRefTotalLength = false;\n\n    if (this._dataSource.filesize != undefined && this._dataSource.filesize !== 0) {\n      useRefTotalLength = true;\n      this._totalLength = this._dataSource.filesize;\n    }\n\n    if (!this._totalLengthReceived && !useRefTotalLength) {\n      // We need total filesize\n      this._waitForTotalLength = true;\n\n      this._internalOpen(this._dataSource, {\n        from: 0,\n        to: -1\n      });\n    } else {\n      // We have filesize, start loading\n      this._openSubRange();\n    }\n  }\n\n  _openSubRange() {\n    let chunkSize = this._currentChunkSizeKB * 1024;\n    let from = this._range.from + this._receivedLength;\n    let to = from + chunkSize;\n\n    if (this._contentLength != null) {\n      if (to - this._range.from >= this._contentLength) {\n        to = this._range.from + this._contentLength - 1;\n      }\n    }\n\n    this._currentRequestRange = {\n      from,\n      to\n    };\n\n    this._internalOpen(this._dataSource, this._currentRequestRange);\n  }\n\n  _internalOpen(dataSource, range) {\n    this._lastTimeLoaded = 0;\n    let sourceURL = dataSource.url;\n\n    if (this._config.reuseRedirectedURL) {\n      if (this._currentRedirectedURL != undefined) {\n        sourceURL = this._currentRedirectedURL;\n      } else if (dataSource.redirectedURL != undefined) {\n        sourceURL = dataSource.redirectedURL;\n      }\n    }\n\n    let seekConfig = this._seekHandler.getConfig(sourceURL, range);\n\n    this._currentRequestURL = seekConfig.url;\n    let xhr = this._xhr = new XMLHttpRequest();\n    xhr.open('GET', seekConfig.url, true);\n    xhr.responseType = 'arraybuffer';\n    xhr.onreadystatechange = this._onReadyStateChange.bind(this);\n    xhr.onprogress = this._onProgress.bind(this);\n    xhr.onload = this._onLoad.bind(this);\n    xhr.onerror = this._onXhrError.bind(this);\n\n    if (dataSource.withCredentials) {\n      xhr.withCredentials = true;\n    }\n\n    if (typeof seekConfig.headers === 'object') {\n      let headers = seekConfig.headers;\n\n      for (let key in headers) {\n        if (headers.hasOwnProperty(key)) {\n          xhr.setRequestHeader(key, headers[key]);\n        }\n      }\n    } // add additional headers\n\n\n    if (typeof this._config.headers === 'object') {\n      let headers = this._config.headers;\n\n      for (let key in headers) {\n        if (headers.hasOwnProperty(key)) {\n          xhr.setRequestHeader(key, headers[key]);\n        }\n      }\n    }\n\n    xhr.send();\n  }\n\n  abort() {\n    this._requestAbort = true;\n\n    this._internalAbort();\n\n    this._status = LoaderStatus.kComplete;\n  }\n\n  _internalAbort() {\n    if (this._xhr) {\n      this._xhr.onreadystatechange = null;\n      this._xhr.onprogress = null;\n      this._xhr.onload = null;\n      this._xhr.onerror = null;\n\n      this._xhr.abort();\n\n      this._xhr = null;\n    }\n  }\n\n  _onReadyStateChange(e) {\n    let xhr = e.target;\n\n    if (xhr.readyState === 2) {\n      // HEADERS_RECEIVED\n      if (xhr.responseURL != undefined) {\n        // if the browser support this property\n        let redirectedURL = this._seekHandler.removeURLParameters(xhr.responseURL);\n\n        if (xhr.responseURL !== this._currentRequestURL && redirectedURL !== this._currentRedirectedURL) {\n          this._currentRedirectedURL = redirectedURL;\n\n          if (this._onURLRedirect) {\n            this._onURLRedirect(redirectedURL);\n          }\n        }\n      }\n\n      if (xhr.status >= 200 && xhr.status <= 299) {\n        if (this._waitForTotalLength) {\n          return;\n        }\n\n        this._status = LoaderStatus.kBuffering;\n      } else {\n        this._status = LoaderStatus.kError;\n\n        if (this._onError) {\n          this._onError(LoaderErrors.HTTP_STATUS_CODE_INVALID, {\n            code: xhr.status,\n            msg: xhr.statusText\n          });\n        } else {\n          throw new RuntimeException('RangeLoader: Http code invalid, ' + xhr.status + ' ' + xhr.statusText);\n        }\n      }\n    }\n  }\n\n  _onProgress(e) {\n    if (this._status === LoaderStatus.kError) {\n      // Ignore error response\n      return;\n    }\n\n    if (this._contentLength === null) {\n      let openNextRange = false;\n\n      if (this._waitForTotalLength) {\n        this._waitForTotalLength = false;\n        this._totalLengthReceived = true;\n        openNextRange = true;\n        let total = e.total;\n\n        this._internalAbort();\n\n        if (total != null & total !== 0) {\n          this._totalLength = total;\n        }\n      } // calculate currrent request range's contentLength\n\n\n      if (this._range.to === -1) {\n        this._contentLength = this._totalLength - this._range.from;\n      } else {\n        // to !== -1\n        this._contentLength = this._range.to - this._range.from + 1;\n      }\n\n      if (openNextRange) {\n        this._openSubRange();\n\n        return;\n      }\n\n      if (this._onContentLengthKnown) {\n        this._onContentLengthKnown(this._contentLength);\n      }\n    }\n\n    let delta = e.loaded - this._lastTimeLoaded;\n    this._lastTimeLoaded = e.loaded;\n\n    this._speedSampler.addBytes(delta);\n  }\n\n  _normalizeSpeed(input) {\n    let list = this._chunkSizeKBList;\n    let last = list.length - 1;\n    let mid = 0;\n    let lbound = 0;\n    let ubound = last;\n\n    if (input < list[0]) {\n      return list[0];\n    }\n\n    while (lbound <= ubound) {\n      mid = lbound + Math.floor((ubound - lbound) / 2);\n\n      if (mid === last || input >= list[mid] && input < list[mid + 1]) {\n        return list[mid];\n      } else if (list[mid] < input) {\n        lbound = mid + 1;\n      } else {\n        ubound = mid - 1;\n      }\n    }\n  }\n\n  _onLoad(e) {\n    if (this._status === LoaderStatus.kError) {\n      // Ignore error response\n      return;\n    }\n\n    if (this._waitForTotalLength) {\n      this._waitForTotalLength = false;\n      return;\n    }\n\n    this._lastTimeLoaded = 0;\n    let KBps = this._speedSampler.lastSecondKBps;\n\n    if (KBps === 0) {\n      this._zeroSpeedChunkCount++;\n\n      if (this._zeroSpeedChunkCount >= 3) {\n        // Try get currentKBps after 3 chunks\n        KBps = this._speedSampler.currentKBps;\n      }\n    }\n\n    if (KBps !== 0) {\n      let normalized = this._normalizeSpeed(KBps);\n\n      if (this._currentSpeedNormalized !== normalized) {\n        this._currentSpeedNormalized = normalized;\n        this._currentChunkSizeKB = normalized;\n      }\n    }\n\n    let chunk = e.target.response;\n    let byteStart = this._range.from + this._receivedLength;\n    this._receivedLength += chunk.byteLength;\n    let reportComplete = false;\n\n    if (this._contentLength != null && this._receivedLength < this._contentLength) {\n      // continue load next chunk\n      this._openSubRange();\n    } else {\n      reportComplete = true;\n    } // dispatch received chunk\n\n\n    if (this._onDataArrival) {\n      this._onDataArrival(chunk, byteStart, this._receivedLength);\n    }\n\n    if (reportComplete) {\n      this._status = LoaderStatus.kComplete;\n\n      if (this._onComplete) {\n        this._onComplete(this._range.from, this._range.from + this._receivedLength - 1);\n      }\n    }\n  }\n\n  _onXhrError(e) {\n    this._status = LoaderStatus.kError;\n    let type = 0;\n    let info = null;\n\n    if (this._contentLength && this._receivedLength > 0 && this._receivedLength < this._contentLength) {\n      type = LoaderErrors.EARLY_EOF;\n      info = {\n        code: -1,\n        msg: 'RangeLoader meet Early-Eof'\n      };\n    } else {\n      type = LoaderErrors.EXCEPTION;\n      info = {\n        code: -1,\n        msg: e.constructor.name + ' ' + e.type\n      };\n    }\n\n    if (this._onError) {\n      this._onError(type, info);\n    } else {\n      throw new RuntimeException(info.msg);\n    }\n  }\n\n}\n\nexport default RangeLoader;","map":null,"metadata":{},"sourceType":"module"}