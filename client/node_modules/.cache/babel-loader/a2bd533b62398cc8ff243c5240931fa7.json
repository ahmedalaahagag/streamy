{"ast":null,"code":"/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport Log from '../utils/logger.js';\nimport SpeedSampler from './speed-sampler.js';\nimport { LoaderStatus, LoaderErrors } from './loader.js';\nimport FetchStreamLoader from './fetch-stream-loader.js';\nimport MozChunkedLoader from './xhr-moz-chunked-loader.js';\nimport MSStreamLoader from './xhr-msstream-loader.js';\nimport RangeLoader from './xhr-range-loader.js';\nimport WebSocketLoader from './websocket-loader.js';\nimport RangeSeekHandler from './range-seek-handler.js';\nimport ParamSeekHandler from './param-seek-handler.js';\nimport { RuntimeException, IllegalStateException, InvalidArgumentException } from '../utils/exception.js';\n/**\n * DataSource: {\n *     url: string,\n *     filesize: number,\n *     cors: boolean,\n *     withCredentials: boolean\n * }\n * \n */\n// Manage IO Loaders\n\nclass IOController {\n  constructor(dataSource, config, extraData) {\n    this.TAG = 'IOController';\n    this._config = config;\n    this._extraData = extraData;\n    this._stashInitialSize = 1024 * 384; // default initial size: 384KB\n\n    if (config.stashInitialSize != undefined && config.stashInitialSize > 0) {\n      // apply from config\n      this._stashInitialSize = config.stashInitialSize;\n    }\n\n    this._stashUsed = 0;\n    this._stashSize = this._stashInitialSize;\n    this._bufferSize = 1024 * 1024 * 3; // initial size: 3MB\n\n    this._stashBuffer = new ArrayBuffer(this._bufferSize);\n    this._stashByteStart = 0;\n    this._enableStash = true;\n\n    if (config.enableStashBuffer === false) {\n      this._enableStash = false;\n    }\n\n    this._loader = null;\n    this._loaderClass = null;\n    this._seekHandler = null;\n    this._dataSource = dataSource;\n    this._isWebSocketURL = /wss?:\\/\\/(.+?)/.test(dataSource.url);\n    this._refTotalLength = dataSource.filesize ? dataSource.filesize : null;\n    this._totalLength = this._refTotalLength;\n    this._fullRequestFlag = false;\n    this._currentRange = null;\n    this._redirectedURL = null;\n    this._speedNormalized = 0;\n    this._speedSampler = new SpeedSampler();\n    this._speedNormalizeList = [64, 128, 256, 384, 512, 768, 1024, 1536, 2048, 3072, 4096];\n    this._isEarlyEofReconnecting = false;\n    this._paused = false;\n    this._resumeFrom = 0;\n    this._onDataArrival = null;\n    this._onSeeked = null;\n    this._onError = null;\n    this._onComplete = null;\n    this._onRedirect = null;\n    this._onRecoveredEarlyEof = null;\n\n    this._selectSeekHandler();\n\n    this._selectLoader();\n\n    this._createLoader();\n  }\n\n  destroy() {\n    if (this._loader.isWorking()) {\n      this._loader.abort();\n    }\n\n    this._loader.destroy();\n\n    this._loader = null;\n    this._loaderClass = null;\n    this._dataSource = null;\n    this._stashBuffer = null;\n    this._stashUsed = this._stashSize = this._bufferSize = this._stashByteStart = 0;\n    this._currentRange = null;\n    this._speedSampler = null;\n    this._isEarlyEofReconnecting = false;\n    this._onDataArrival = null;\n    this._onSeeked = null;\n    this._onError = null;\n    this._onComplete = null;\n    this._onRedirect = null;\n    this._onRecoveredEarlyEof = null;\n    this._extraData = null;\n  }\n\n  isWorking() {\n    return this._loader && this._loader.isWorking() && !this._paused;\n  }\n\n  isPaused() {\n    return this._paused;\n  }\n\n  get status() {\n    return this._loader.status;\n  }\n\n  get extraData() {\n    return this._extraData;\n  }\n\n  set extraData(data) {\n    this._extraData = data;\n  } // prototype: function onDataArrival(chunks: ArrayBuffer, byteStart: number): number\n\n\n  get onDataArrival() {\n    return this._onDataArrival;\n  }\n\n  set onDataArrival(callback) {\n    this._onDataArrival = callback;\n  }\n\n  get onSeeked() {\n    return this._onSeeked;\n  }\n\n  set onSeeked(callback) {\n    this._onSeeked = callback;\n  } // prototype: function onError(type: number, info: {code: number, msg: string}): void\n\n\n  get onError() {\n    return this._onError;\n  }\n\n  set onError(callback) {\n    this._onError = callback;\n  }\n\n  get onComplete() {\n    return this._onComplete;\n  }\n\n  set onComplete(callback) {\n    this._onComplete = callback;\n  }\n\n  get onRedirect() {\n    return this._onRedirect;\n  }\n\n  set onRedirect(callback) {\n    this._onRedirect = callback;\n  }\n\n  get onRecoveredEarlyEof() {\n    return this._onRecoveredEarlyEof;\n  }\n\n  set onRecoveredEarlyEof(callback) {\n    this._onRecoveredEarlyEof = callback;\n  }\n\n  get currentURL() {\n    return this._dataSource.url;\n  }\n\n  get hasRedirect() {\n    return this._redirectedURL != null || this._dataSource.redirectedURL != undefined;\n  }\n\n  get currentRedirectedURL() {\n    return this._redirectedURL || this._dataSource.redirectedURL;\n  } // in KB/s\n\n\n  get currentSpeed() {\n    if (this._loaderClass === RangeLoader) {\n      // SpeedSampler is inaccuracy if loader is RangeLoader\n      return this._loader.currentSpeed;\n    }\n\n    return this._speedSampler.lastSecondKBps;\n  }\n\n  get loaderType() {\n    return this._loader.type;\n  }\n\n  _selectSeekHandler() {\n    let config = this._config;\n\n    if (config.seekType === 'range') {\n      this._seekHandler = new RangeSeekHandler(this._config.rangeLoadZeroStart);\n    } else if (config.seekType === 'param') {\n      let paramStart = config.seekParamStart || 'bstart';\n      let paramEnd = config.seekParamEnd || 'bend';\n      this._seekHandler = new ParamSeekHandler(paramStart, paramEnd);\n    } else if (config.seekType === 'custom') {\n      if (typeof config.customSeekHandler !== 'function') {\n        throw new InvalidArgumentException('Custom seekType specified in config but invalid customSeekHandler!');\n      }\n\n      this._seekHandler = new config.customSeekHandler();\n    } else {\n      throw new InvalidArgumentException(\"Invalid seekType in config: \".concat(config.seekType));\n    }\n  }\n\n  _selectLoader() {\n    if (this._config.customLoader != null) {\n      this._loaderClass = this._config.customLoader;\n    } else if (this._isWebSocketURL) {\n      this._loaderClass = WebSocketLoader;\n    } else if (FetchStreamLoader.isSupported()) {\n      this._loaderClass = FetchStreamLoader;\n    } else if (MozChunkedLoader.isSupported()) {\n      this._loaderClass = MozChunkedLoader;\n    } else if (RangeLoader.isSupported()) {\n      this._loaderClass = RangeLoader;\n    } else {\n      throw new RuntimeException('Your browser doesn\\'t support xhr with arraybuffer responseType!');\n    }\n  }\n\n  _createLoader() {\n    this._loader = new this._loaderClass(this._seekHandler, this._config);\n\n    if (this._loader.needStashBuffer === false) {\n      this._enableStash = false;\n    }\n\n    this._loader.onContentLengthKnown = this._onContentLengthKnown.bind(this);\n    this._loader.onURLRedirect = this._onURLRedirect.bind(this);\n    this._loader.onDataArrival = this._onLoaderChunkArrival.bind(this);\n    this._loader.onComplete = this._onLoaderComplete.bind(this);\n    this._loader.onError = this._onLoaderError.bind(this);\n  }\n\n  open(optionalFrom) {\n    this._currentRange = {\n      from: 0,\n      to: -1\n    };\n\n    if (optionalFrom) {\n      this._currentRange.from = optionalFrom;\n    }\n\n    this._speedSampler.reset();\n\n    if (!optionalFrom) {\n      this._fullRequestFlag = true;\n    }\n\n    this._loader.open(this._dataSource, Object.assign({}, this._currentRange));\n  }\n\n  abort() {\n    this._loader.abort();\n\n    if (this._paused) {\n      this._paused = false;\n      this._resumeFrom = 0;\n    }\n  }\n\n  pause() {\n    if (this.isWorking()) {\n      this._loader.abort();\n\n      if (this._stashUsed !== 0) {\n        this._resumeFrom = this._stashByteStart;\n        this._currentRange.to = this._stashByteStart - 1;\n      } else {\n        this._resumeFrom = this._currentRange.to + 1;\n      }\n\n      this._stashUsed = 0;\n      this._stashByteStart = 0;\n      this._paused = true;\n    }\n  }\n\n  resume() {\n    if (this._paused) {\n      this._paused = false;\n      let bytes = this._resumeFrom;\n      this._resumeFrom = 0;\n\n      this._internalSeek(bytes, true);\n    }\n  }\n\n  seek(bytes) {\n    this._paused = false;\n    this._stashUsed = 0;\n    this._stashByteStart = 0;\n\n    this._internalSeek(bytes, true);\n  }\n  /**\n   * When seeking request is from media seeking, unconsumed stash data should be dropped\n   * However, stash data shouldn't be dropped if seeking requested from http reconnection\n   *\n   * @dropUnconsumed: Ignore and discard all unconsumed data in stash buffer\n   */\n\n\n  _internalSeek(bytes, dropUnconsumed) {\n    if (this._loader.isWorking()) {\n      this._loader.abort();\n    } // dispatch & flush stash buffer before seek\n\n\n    this._flushStashBuffer(dropUnconsumed);\n\n    this._loader.destroy();\n\n    this._loader = null;\n    let requestRange = {\n      from: bytes,\n      to: -1\n    };\n    this._currentRange = {\n      from: requestRange.from,\n      to: -1\n    };\n\n    this._speedSampler.reset();\n\n    this._stashSize = this._stashInitialSize;\n\n    this._createLoader();\n\n    this._loader.open(this._dataSource, requestRange);\n\n    if (this._onSeeked) {\n      this._onSeeked();\n    }\n  }\n\n  updateUrl(url) {\n    if (!url || typeof url !== 'string' || url.length === 0) {\n      throw new InvalidArgumentException('Url must be a non-empty string!');\n    }\n\n    this._dataSource.url = url; // TODO: replace with new url\n  }\n\n  _expandBuffer(expectedBytes) {\n    let bufferNewSize = this._stashSize;\n\n    while (bufferNewSize + 1024 * 1024 * 1 < expectedBytes) {\n      bufferNewSize *= 2;\n    }\n\n    bufferNewSize += 1024 * 1024 * 1; // bufferSize = stashSize + 1MB\n\n    if (bufferNewSize === this._bufferSize) {\n      return;\n    }\n\n    let newBuffer = new ArrayBuffer(bufferNewSize);\n\n    if (this._stashUsed > 0) {\n      // copy existing data into new buffer\n      let stashOldArray = new Uint8Array(this._stashBuffer, 0, this._stashUsed);\n      let stashNewArray = new Uint8Array(newBuffer, 0, bufferNewSize);\n      stashNewArray.set(stashOldArray, 0);\n    }\n\n    this._stashBuffer = newBuffer;\n    this._bufferSize = bufferNewSize;\n  }\n\n  _normalizeSpeed(input) {\n    let list = this._speedNormalizeList;\n    let last = list.length - 1;\n    let mid = 0;\n    let lbound = 0;\n    let ubound = last;\n\n    if (input < list[0]) {\n      return list[0];\n    } // binary search\n\n\n    while (lbound <= ubound) {\n      mid = lbound + Math.floor((ubound - lbound) / 2);\n\n      if (mid === last || input >= list[mid] && input < list[mid + 1]) {\n        return list[mid];\n      } else if (list[mid] < input) {\n        lbound = mid + 1;\n      } else {\n        ubound = mid - 1;\n      }\n    }\n  }\n\n  _adjustStashSize(normalized) {\n    let stashSizeKB = 0;\n\n    if (this._config.isLive) {\n      // live stream: always use single normalized speed for size of stashSizeKB\n      stashSizeKB = normalized;\n    } else {\n      if (normalized < 512) {\n        stashSizeKB = normalized;\n      } else if (normalized >= 512 && normalized <= 1024) {\n        stashSizeKB = Math.floor(normalized * 1.5);\n      } else {\n        stashSizeKB = normalized * 2;\n      }\n    }\n\n    if (stashSizeKB > 8192) {\n      stashSizeKB = 8192;\n    }\n\n    let bufferSize = stashSizeKB * 1024 + 1024 * 1024 * 1; // stashSize + 1MB\n\n    if (this._bufferSize < bufferSize) {\n      this._expandBuffer(bufferSize);\n    }\n\n    this._stashSize = stashSizeKB * 1024;\n  }\n\n  _dispatchChunks(chunks, byteStart) {\n    this._currentRange.to = byteStart + chunks.byteLength - 1;\n    return this._onDataArrival(chunks, byteStart);\n  }\n\n  _onURLRedirect(redirectedURL) {\n    this._redirectedURL = redirectedURL;\n\n    if (this._onRedirect) {\n      this._onRedirect(redirectedURL);\n    }\n  }\n\n  _onContentLengthKnown(contentLength) {\n    if (contentLength && this._fullRequestFlag) {\n      this._totalLength = contentLength;\n      this._fullRequestFlag = false;\n    }\n  }\n\n  _onLoaderChunkArrival(chunk, byteStart, receivedLength) {\n    if (!this._onDataArrival) {\n      throw new IllegalStateException('IOController: No existing consumer (onDataArrival) callback!');\n    }\n\n    if (this._paused) {\n      return;\n    }\n\n    if (this._isEarlyEofReconnecting) {\n      // Auto-reconnect for EarlyEof succeed, notify to upper-layer by callback\n      this._isEarlyEofReconnecting = false;\n\n      if (this._onRecoveredEarlyEof) {\n        this._onRecoveredEarlyEof();\n      }\n    }\n\n    this._speedSampler.addBytes(chunk.byteLength); // adjust stash buffer size according to network speed dynamically\n\n\n    let KBps = this._speedSampler.lastSecondKBps;\n\n    if (KBps !== 0) {\n      let normalized = this._normalizeSpeed(KBps);\n\n      if (this._speedNormalized !== normalized) {\n        this._speedNormalized = normalized;\n\n        this._adjustStashSize(normalized);\n      }\n    }\n\n    if (!this._enableStash) {\n      // disable stash\n      if (this._stashUsed === 0) {\n        // dispatch chunk directly to consumer;\n        // check ret value (consumed bytes) and stash unconsumed to stashBuffer\n        let consumed = this._dispatchChunks(chunk, byteStart);\n\n        if (consumed < chunk.byteLength) {\n          // unconsumed data remain.\n          let remain = chunk.byteLength - consumed;\n\n          if (remain > this._bufferSize) {\n            this._expandBuffer(remain);\n          }\n\n          let stashArray = new Uint8Array(this._stashBuffer, 0, this._bufferSize);\n          stashArray.set(new Uint8Array(chunk, consumed), 0);\n          this._stashUsed += remain;\n          this._stashByteStart = byteStart + consumed;\n        }\n      } else {\n        // else: Merge chunk into stashBuffer, and dispatch stashBuffer to consumer.\n        if (this._stashUsed + chunk.byteLength > this._bufferSize) {\n          this._expandBuffer(this._stashUsed + chunk.byteLength);\n        }\n\n        let stashArray = new Uint8Array(this._stashBuffer, 0, this._bufferSize);\n        stashArray.set(new Uint8Array(chunk), this._stashUsed);\n        this._stashUsed += chunk.byteLength;\n\n        let consumed = this._dispatchChunks(this._stashBuffer.slice(0, this._stashUsed), this._stashByteStart);\n\n        if (consumed < this._stashUsed && consumed > 0) {\n          // unconsumed data remain\n          let remainArray = new Uint8Array(this._stashBuffer, consumed);\n          stashArray.set(remainArray, 0);\n        }\n\n        this._stashUsed -= consumed;\n        this._stashByteStart += consumed;\n      }\n    } else {\n      // enable stash\n      if (this._stashUsed === 0 && this._stashByteStart === 0) {\n        // seeked? or init chunk?\n        // This is the first chunk after seek action\n        this._stashByteStart = byteStart;\n      }\n\n      if (this._stashUsed + chunk.byteLength <= this._stashSize) {\n        // just stash\n        let stashArray = new Uint8Array(this._stashBuffer, 0, this._stashSize);\n        stashArray.set(new Uint8Array(chunk), this._stashUsed);\n        this._stashUsed += chunk.byteLength;\n      } else {\n        // stashUsed + chunkSize > stashSize, size limit exceeded\n        let stashArray = new Uint8Array(this._stashBuffer, 0, this._bufferSize);\n\n        if (this._stashUsed > 0) {\n          // There're stash datas in buffer\n          // dispatch the whole stashBuffer, and stash remain data\n          // then append chunk to stashBuffer (stash)\n          let buffer = this._stashBuffer.slice(0, this._stashUsed);\n\n          let consumed = this._dispatchChunks(buffer, this._stashByteStart);\n\n          if (consumed < buffer.byteLength) {\n            if (consumed > 0) {\n              let remainArray = new Uint8Array(buffer, consumed);\n              stashArray.set(remainArray, 0);\n              this._stashUsed = remainArray.byteLength;\n              this._stashByteStart += consumed;\n            }\n          } else {\n            this._stashUsed = 0;\n            this._stashByteStart += consumed;\n          }\n\n          if (this._stashUsed + chunk.byteLength > this._bufferSize) {\n            this._expandBuffer(this._stashUsed + chunk.byteLength);\n\n            stashArray = new Uint8Array(this._stashBuffer, 0, this._bufferSize);\n          }\n\n          stashArray.set(new Uint8Array(chunk), this._stashUsed);\n          this._stashUsed += chunk.byteLength;\n        } else {\n          // stash buffer empty, but chunkSize > stashSize (oh, holy shit)\n          // dispatch chunk directly and stash remain data\n          let consumed = this._dispatchChunks(chunk, byteStart);\n\n          if (consumed < chunk.byteLength) {\n            let remain = chunk.byteLength - consumed;\n\n            if (remain > this._bufferSize) {\n              this._expandBuffer(remain);\n\n              stashArray = new Uint8Array(this._stashBuffer, 0, this._bufferSize);\n            }\n\n            stashArray.set(new Uint8Array(chunk, consumed), 0);\n            this._stashUsed += remain;\n            this._stashByteStart = byteStart + consumed;\n          }\n        }\n      }\n    }\n  }\n\n  _flushStashBuffer(dropUnconsumed) {\n    if (this._stashUsed > 0) {\n      let buffer = this._stashBuffer.slice(0, this._stashUsed);\n\n      let consumed = this._dispatchChunks(buffer, this._stashByteStart);\n\n      let remain = buffer.byteLength - consumed;\n\n      if (consumed < buffer.byteLength) {\n        if (dropUnconsumed) {\n          Log.w(this.TAG, \"\".concat(remain, \" bytes unconsumed data remain when flush buffer, dropped\"));\n        } else {\n          if (consumed > 0) {\n            let stashArray = new Uint8Array(this._stashBuffer, 0, this._bufferSize);\n            let remainArray = new Uint8Array(buffer, consumed);\n            stashArray.set(remainArray, 0);\n            this._stashUsed = remainArray.byteLength;\n            this._stashByteStart += consumed;\n          }\n\n          return 0;\n        }\n      }\n\n      this._stashUsed = 0;\n      this._stashByteStart = 0;\n      return remain;\n    }\n\n    return 0;\n  }\n\n  _onLoaderComplete(from, to) {\n    // Force-flush stash buffer, and drop unconsumed data\n    this._flushStashBuffer(true);\n\n    if (this._onComplete) {\n      this._onComplete(this._extraData);\n    }\n  }\n\n  _onLoaderError(type, data) {\n    Log.e(this.TAG, \"Loader error, code = \".concat(data.code, \", msg = \").concat(data.msg));\n\n    this._flushStashBuffer(false);\n\n    if (this._isEarlyEofReconnecting) {\n      // Auto-reconnect for EarlyEof failed, throw UnrecoverableEarlyEof error to upper-layer\n      this._isEarlyEofReconnecting = false;\n      type = LoaderErrors.UNRECOVERABLE_EARLY_EOF;\n    }\n\n    switch (type) {\n      case LoaderErrors.EARLY_EOF:\n        {\n          if (!this._config.isLive) {\n            // Do internal http reconnect if not live stream\n            if (this._totalLength) {\n              let nextFrom = this._currentRange.to + 1;\n\n              if (nextFrom < this._totalLength) {\n                Log.w(this.TAG, 'Connection lost, trying reconnect...');\n                this._isEarlyEofReconnecting = true;\n\n                this._internalSeek(nextFrom, false);\n              }\n\n              return;\n            } // else: We don't know totalLength, throw UnrecoverableEarlyEof\n\n          } // live stream: throw UnrecoverableEarlyEof error to upper-layer\n\n\n          type = LoaderErrors.UNRECOVERABLE_EARLY_EOF;\n          break;\n        }\n\n      case LoaderErrors.UNRECOVERABLE_EARLY_EOF:\n      case LoaderErrors.CONNECTING_TIMEOUT:\n      case LoaderErrors.HTTP_STATUS_CODE_INVALID:\n      case LoaderErrors.EXCEPTION:\n        break;\n    }\n\n    if (this._onError) {\n      this._onError(type, data);\n    } else {\n      throw new RuntimeException('IOException: ' + data.msg);\n    }\n  }\n\n}\n\nexport default IOController;","map":null,"metadata":{},"sourceType":"module"}